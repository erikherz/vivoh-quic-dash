<!DOCTYPE html>
<html>
<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <link rel="icon" href="data:;base64,=">
    <title>Vivoh WebTransport DASH Player</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .mainContainer {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }
        .url-input {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        .video-container {
            margin: 20px 0;
            background: #000;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        .video-logo {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 100px;
            opacity: 0.8;
        }
        .centeredVideo {
            width: 100%;
            margin: 0 auto;
            display: block;
        }
        .logcatBox {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            background: #f8f9fa;
            height: 200px;
            overflow-y: auto;
            text-align: left;
            margin-top: 20px;
        }
        .controls {
            margin: 20px 0;
        }
        .btn {
            background-color: #1e88e5;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 0 10px;
            transition: background-color 0.3s;
        }
        .btn:hover {
            background-color: #1565c0;
        }
        .btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        input[type="text"] {
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #ddd;
            width: 80%;
            font-size: 16px;
        }
        label {
            font-weight: bold;
            white-space: nowrap;
        }
        .status-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 10px 0;
        }
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .status-label {
            font-weight: bold;
        }
        .status-badge {
            background-color: #f0f0f0;
            padding: 5px 10px;
            border-radius: 12px;
            font-size: 14px;
        }
        .status-connected {
            background-color: #4caf50;
            color: white;
        }
        .status-disconnected {
            background-color: #f44336;
            color: white;
        }
        .status-buffering {
            background-color: #ff9800;
            color: white;
        }
    </style>
</head>
<body>
    <div class="mainContainer">
        <img src="vivoh.png" class="video-logo" alt="Video Logo">
        <div class="url-input">
            <label for="wtUrl">WebTransport URL:</label>
            <input id="wtUrl" type="text" value="https://va01.wtmpeg.com/live" style="width: 70%; padding: 10px;">
        </div>
        <div class="video-container">
            <video id="videoElement" class="centeredVideo" controls playsinline>
                Your browser is too old which doesn't support HTML5 video.
            </video>
        </div>
        <div class="status-container">
            <div class="status-indicator">
                <span class="status-label">Connection:</span>
                <span id="connectionStatus" class="status-badge status-disconnected">Disconnected</span>
            </div>
            <div class="status-indicator">
                <span class="status-label">DASH Fragments:</span>
                <span id="bufferStatus" class="status-badge">0 fragments</span>
            </div>
            <div class="status-indicator">
                <span class="status-label">Player:</span>
                <span id="playerStatus" class="status-badge">Idle</span>
            </div>
            <div class="status-indicator">
                <span class="status-label">QUIC Streams:</span>
                <span id="streamCounter" class="status-badge">0</span>
            </div>
            <div class="status-indicator">
                <span class="status-label">Media Packets:</span>
                <span id="packetCounter" class="status-badge">0</span>
            </div>
        </div>
        <div class="controls">
            <button id="connectButton" class="btn">Connect</button>
            <button id="playButton" class="btn" disabled>Play</button>
            <button id="disconnectButton" class="btn" disabled>Disconnect</button>
        </div>
        <textarea id="logcatbox" class="logcatBox" rows="10" readonly></textarea>
    </div>

    <script src="dash.js"></script>
    <script>
// At the top of your script, modify the global variable declarations:

// Global variables
let transport;
let packetHandler;
let statusInterval;
let player;
let playerState = 'idle';
let disconnectionRequested = false;
let activeReaders = [];
let xhrInterceptionEnabled = false;
let streamCounter = 0;
let bufferLoggingIntervals = [];

// Also add them to window for global access
window.transport = transport;
window.packetHandler = packetHandler;
window.statusInterval = statusInterval;
window.player = player;
window.playerState = playerState;
window.disconnectionRequested = disconnectionRequested;
window.activeReaders = activeReaders;
window.xhrInterceptionEnabled = xhrInterceptionEnabled;
window.streamCounter = streamCounter;
window.bufferLoggingIntervals = bufferLoggingIntervals;

// Constants from server implementation
const PUBLISHER_ROLE_HEADER = new TextEncoder().encode("DOQ-PUB-ROLE-V1");
const PLAYER_ROLE_HEADER = new TextEncoder().encode("DOQ-PLAYER-ROLE-V1");

// Logging function
function log(message) {
    const logEl = document.getElementById('logcatbox');
    const time = new Date().toISOString().split('T')[1].split('.')[0];
    logEl.value += `[${time}] ${message}\n`;
    logEl.scrollTop = logEl.scrollHeight;
    console.log(message);
}



/**
 * WebTransportMediaPacketHandler
 * 
 * Processes media packets received over WebTransport and manages
 * media fragments for DASH playback.
 */
 class WebTransportMediaPacketHandler {
    /**
     * Create a new WebTransportMediaPacketHandler instance
     */
    constructor() {
        // Media buffers by track type
        this.buffer = {
            video: {}, // Map of packetId -> fragment data
            audio: {}  // Map of packetId -> fragment data
        };
        
        // Initialization segments
        this.init = {
            video: null,
            audio: null
        };
        
        // MPD content
        this.mpdData = null;
        this.mpdUrl = '/vivoh.mpd';
        
        // Track-specific buffers with additional metadata
        this.trackBuffers = {
            0: {  // Video track
                fragments: [],
                lastSequence: -1
            },
            1: {  // Audio track
                fragments: [],
                lastSequence: -1
            }
        };
        
        // Statistics and state
        this.bytesReceived = 0;
        this.fragmentsReceived = 0;
        this.wmpPacketsReceived = 0;
        this.lastProcessedPacketId = -1;
        this.isDisconnected = false;
        
        // Event callback
        this.onMpdReady = null;
    }
    
    /**
     * Process a WebTransport Media Packet from the server
     * 
     * @param {Uint8Array|ArrayBuffer} data - The packet data
     * @returns {boolean} - Whether processing was successful
     */
    processWMPPacket(data) {
        try {
            // Convert data to Uint8Array if needed
            const dataArray = this._ensureUint8Array(data);
            
            // Validate minimum packet size (header + 5 length fields)
            if (dataArray.length < 36) {
                log(`‚ö†Ô∏è Packet too small: ${dataArray.length} bytes (minimum 36 required)`);
                return false;
            }
            
            // Parse the header and get fields
            const {
                packetId,
                timestamp,
                duration,
                fields
            } = this._extractPacketHeader(dataArray);
            
            // Check for duplicate packets
            if (packetId === this.lastProcessedPacketId) {
                log(`üîÑ Duplicate packet ID: ${packetId}, ignoring`);
                return true;
            }
            
            // Update tracking stats
            this.lastProcessedPacketId = packetId;
            this.wmpPacketsReceived++;
            
            // Extract MPD data from the packet if not already set
            if (!this.mpdData && fields.mpd.byteLength > 0) {
                this._processMpdData(fields.mpd);
            }
            
            // Extract initialization segments from the packet if not already set
            if (!this.init.audio && fields.audioInit.byteLength > 0) {
                this.init.audio = fields.audioInit;
                log(`‚úÖ Extracted audio init segment from packet #${packetId} (${fields.audioInit.byteLength} bytes)`);
            }
            
            if (!this.init.video && fields.videoInit.byteLength > 0) {
                this.init.video = fields.videoInit;
                log(`‚úÖ Extracted video init segment from packet #${packetId} (${fields.videoInit.byteLength} bytes)`);
            }
            
            // Process the media fragments
            if (fields.audioData.byteLength > 0) {
                this._processMediaFragment(1, packetId, fields.audioData, false);
            }
            
            if (fields.videoData.byteLength > 0) {
                this._processMediaFragment(0, packetId, fields.videoData, true);
            }
            
            // Log periodic stats
            if (this.wmpPacketsReceived % 10 === 0) {
                const tsSeconds = Number(timestamp) / 1000000; // Convert microseconds to seconds
                log(`üìà Packet stats: Received=${this.wmpPacketsReceived}, ` +
                    `TS=${tsSeconds.toFixed(3)}s, Duration=${duration}ms, ` +
                    `Buffer size: V=${Object.keys(this.buffer.video).length}, ` +
                    `A=${Object.keys(this.buffer.audio).length}`);
            }
            
            // Update stats
            this.fragmentsReceived += 2; // Audio and video
            this.bytesReceived += dataArray.byteLength;
            
            // Check if we have enough data to start playback
            this._checkPlaybackReadiness();
            
            return true;
        } catch (error) {
            log(`‚ùå Error processing packet: ${error.message}`);
            return false;
        }
    }
    
    /**
     * Convert incoming data to Uint8Array
     * 
     * @param {Uint8Array|ArrayBuffer|object} data - The input data
     * @returns {Uint8Array} - Normalized data as Uint8Array
     * @private
     */
    _ensureUint8Array(data) {
        if (data instanceof ArrayBuffer) {
            return new Uint8Array(data);
        } else if (data instanceof Uint8Array) {
            return data;
        } else if (data && typeof data === 'object' && 'buffer' in data) {
            // Handle Node.js Buffer or similar buffer-view objects
            return new Uint8Array(data.buffer, data.byteOffset || 0, data.byteLength);
        } else {
            throw new Error(`Invalid data type for packet: ${typeof data}`);
        }
    }
    
 /**
 * Extract header fields and media data from a packet
 * 
 * @param {Uint8Array} dataArray - The packet data
 * @returns {object} - Extracted header fields and media data
 * @private
 */
_extractPacketHeader(dataArray) {
    // Log packet size for debugging
    log(`üîç Processing packet with size: ${dataArray.byteLength} bytes`);
    
    const view = new DataView(dataArray.buffer, dataArray.byteOffset, dataArray.byteLength);
    
    // Extract header fields
    const packetId = view.getUint32(0);
    const timestamp = view.getBigUint64(4);
    const duration = view.getUint32(12);
    
    // Extract field lengths with validation and debugging
    const fieldLengths = [];
    try {
        fieldLengths.push(view.getUint32(16)); // mpd length
        fieldLengths.push(view.getUint32(20)); // audio_init length
        fieldLengths.push(view.getUint32(24)); // video_init length
        fieldLengths.push(view.getUint32(28)); // audio_data length
        fieldLengths.push(view.getUint32(32)); // video_data length
        
        // Log field lengths for debugging
        log(`üîç Field lengths: MPD=${fieldLengths[0]}, AudioInit=${fieldLengths[1]}, VideoInit=${fieldLengths[2]}, AudioData=${fieldLengths[3]}, VideoData=${fieldLengths[4]}`);
        
        // Validate that field lengths make sense
        const totalFieldsSize = fieldLengths.reduce((sum, len) => sum + len, 0);
        log(`üîç Total fields size: ${totalFieldsSize}, Packet size: ${dataArray.byteLength}, Header size: 36`);
        
        if (totalFieldsSize + 36 > dataArray.byteLength) {
            log(`‚ö†Ô∏è Warning: Field lengths (${totalFieldsSize}) + header (36) exceed packet size (${dataArray.byteLength})`);
        }
    } catch (error) {
        log(`‚ùå Error extracting field lengths: ${error.message}`);
        // Provide default values to avoid crashes
        while (fieldLengths.length < 5) fieldLengths.push(0);
    }
    
    // Calculate field positions
    let position = 36;  // Start after header and field lengths
    const fields = {
        mpd: new Uint8Array(0),
        audioInit: new Uint8Array(0),
        videoInit: new Uint8Array(0),
        audioData: new Uint8Array(0),
        videoData: new Uint8Array(0)
    };
    
    // Extract each field with enhanced validation
    try {
        // Extract MPD data
        if (fieldLengths[0] > 0) {
            if (position + fieldLengths[0] <= dataArray.byteLength) {
                fields.mpd = dataArray.slice(position, position + fieldLengths[0]);
                log(`‚úÖ Extracted MPD field: ${fields.mpd.byteLength} bytes`);
            } else {
                log(`‚ö†Ô∏è MPD field extends beyond packet bounds: pos=${position}, len=${fieldLengths[0]}, available=${dataArray.byteLength - position}`);
            }
            position += fieldLengths[0];
        }
        
        // Extract audio init segment
        if (fieldLengths[1] > 0) {
            if (position + fieldLengths[1] <= dataArray.byteLength) {
                fields.audioInit = dataArray.slice(position, position + fieldLengths[1]);
                log(`‚úÖ Extracted AudioInit field: ${fields.audioInit.byteLength} bytes`);
            } else {
                log(`‚ö†Ô∏è AudioInit field extends beyond packet bounds: pos=${position}, len=${fieldLengths[1]}, available=${dataArray.byteLength - position}`);
            }
            position += fieldLengths[1];
        }
        
        // Extract video init segment
        if (fieldLengths[2] > 0) {
            if (position + fieldLengths[2] <= dataArray.byteLength) {
                fields.videoInit = dataArray.slice(position, position + fieldLengths[2]);
                log(`‚úÖ Extracted VideoInit field: ${fields.videoInit.byteLength} bytes`);
            } else {
                log(`‚ö†Ô∏è VideoInit field extends beyond packet bounds: pos=${position}, len=${fieldLengths[2]}, available=${dataArray.byteLength - position}`);
            }
            position += fieldLengths[2];
        }
        
        // Extract audio data
        if (fieldLengths[3] > 0) {
            if (position + fieldLengths[3] <= dataArray.byteLength) {
                fields.audioData = dataArray.slice(position, position + fieldLengths[3]);
                log(`‚úÖ Extracted AudioData field: ${fields.audioData.byteLength} bytes`);
            } else {
                log(`‚ö†Ô∏è AudioData field extends beyond packet bounds: pos=${position}, len=${fieldLengths[3]}, available=${dataArray.byteLength - position}`);
            }
            position += fieldLengths[3];
        }
        
        // Extract video data
        if (fieldLengths[4] > 0) {
            if (position + fieldLengths[4] <= dataArray.byteLength) {
                fields.videoData = dataArray.slice(position, position + fieldLengths[4]);
                log(`‚úÖ Extracted VideoData field: ${fields.videoData.byteLength} bytes`);
            } else {
                log(`‚ö†Ô∏è VideoData field extends beyond packet bounds: pos=${position}, len=${fieldLengths[4]}, available=${dataArray.byteLength - position}`);
            }
        }
    } catch (error) {
        log(`‚ùå Error extracting fields: ${error.message}`);
    }
    
    return {
        packetId,
        timestamp,
        duration,
        fields
    };
}
    
    /**
     * Process MPD data from a packet
     * 
     * @param {Uint8Array} data - The MPD data
     * @private
     */
    _processMpdData(data) {
        if (data.byteLength === 0) return;
        
        try {
            // Convert the binary MPD data to a string
            const mpdString = new TextDecoder().decode(data);
            this.mpdData = mpdString;
            
            log(`üìÑ Extracted MPD data (${data.byteLength} bytes)`);
            
            // Create a Blob URL for the MPD if needed
            if (typeof URL !== 'undefined' && URL.createObjectURL) {
                const blob = new Blob([mpdString], { type: 'application/dash+xml' });
                this.mpdUrl = URL.createObjectURL(blob);
                log(`üîó Created MPD blob URL: ${this.mpdUrl}`);
                
                // Register the MPD blob URL if the function exists
                if (typeof window.registerMpdBlobUrl === 'function') {
                    window.registerMpdBlobUrl(this.mpdUrl, mpdString);
                }
            }
            
            // Notify that the MPD is ready
            if (typeof this.onMpdReady === 'function') {
                this.onMpdReady(this.mpdUrl);
            }
        } catch (error) {
            log(`‚ùå Error processing MPD data: ${error.message}`);
        }
    }
    
    /**
     * Process a media fragment
     * 
     * @param {number} trackId - Track ID (0=video, 1=audio)
     * @param {number} packetId - Packet sequence number
     * @param {Uint8Array} mediaData - The media data
     * @param {boolean} isVideo - Whether this is a video fragment
     * @private
     */
    _processMediaFragment(trackId, packetId, mediaData, isVideo) {
        const trackType = isVideo ? "video" : "audio";
        
        // Skip empty fragments
        if (mediaData.byteLength === 0) {
            return;
        }
        
        // Enhanced fragment validation
        if (mediaData.byteLength < 8) {
            log(`‚ö†Ô∏è Fragment too small: ${mediaData.byteLength} bytes (minimum 8 required)`);
            return;
        }
        
        // Log the box type for debugging (first 4 bytes = size, next 4 = type)
        if (mediaData.byteLength >= 8) {
            const boxType = String.fromCharCode(
                mediaData[4], mediaData[5], mediaData[6], mediaData[7]
            );
            
            if (packetId % 10 === 0) {
                log(`üß™ Fragment ${packetId} (${trackType}) starts with box: ${boxType}`);
            }
        }
        
        // Add fragment to buffer with proper indexing
        this.buffer[trackType][packetId] = mediaData;
        
        // Also add to track-specific buffers for better organization
        if (!this.trackBuffers[trackId]) {
            this.trackBuffers[trackId] = { fragments: [], lastSequence: -1 };
        }
        
        // Add to fragments array with sequence info
        this.trackBuffers[trackId].fragments.push({
            sequence: packetId,
            data: mediaData,
            isKeyframe: isVideo, // For simplicity, treat all video fragments as keyframes
            timestamp: Date.now()
        });
        
        // Register the media segment in the XHR interception map if available
        if (typeof window.registerMediaSegment === 'function') {
            window.registerMediaSegment(trackId, packetId, mediaData);
        }
        
        // Log fragment details for video (less frequently for audio to reduce log spam)
        if (isVideo && packetId % 10 === 0) {
            log(`üì¶ ${trackType} fragment #${packetId} processed, size=${mediaData.byteLength}B`);
        }
        
        // Keep buffer size reasonable (keep last 30 fragments)
        if (this.trackBuffers[trackId].fragments.length > 30) {
            this.trackBuffers[trackId].fragments.sort((a, b) => a.sequence - b.sequence);
            this.trackBuffers[trackId].fragments = this.trackBuffers[trackId].fragments.slice(-30);
            
            // Also clean up the main buffer
            const oldKeys = Object.keys(this.buffer[trackType])
                .map(Number)
                .sort((a, b) => a - b)
                .slice(0, -30);
                
            for (const key of oldKeys) {
                delete this.buffer[trackType][key];
            }
        }
        
        // Update last sequence
        this.trackBuffers[trackId].lastSequence = Math.max(
            this.trackBuffers[trackId].lastSequence, 
            packetId
        );
    }
    
    /**
     * Check if we have enough data to start playback
     * @private
     */
    _checkPlaybackReadiness() {
        // If player already exists, don't create another one
        if (window.player) {
            return;
        }
        
        // Check if we have initialization segments and MPD
        const hasVideoInit = this.init.video !== null;
        const hasAudioInit = this.init.audio !== null;
        const hasMpd = this.mpdData !== null;
        
        // Check if we have enough fragments
        const videoCount = Object.keys(this.buffer.video).length;
        const audioCount = Object.keys(this.buffer.audio).length;
        
        // Wait until we have enough data to start playback
        if (hasVideoInit && hasAudioInit && hasMpd && videoCount >= 3 && audioCount >= 3) {
            log(`‚úÖ Media ready: MPD=${hasMpd}, V=${videoCount}/${hasVideoInit}, A=${audioCount}/${hasAudioInit}`);
            
            // Notify that we're ready to initialize the player
            if (typeof this.onMpdReady === 'function') {
                this.onMpdReady(this.mpdUrl);
            }
        }
    }
    
    /**
     * Get a media fragment by track and segment ID
     * 
     * @param {number} trackId - Track ID (0=video, 1=audio)
     * @param {number} segmentId - Segment sequence number
     * @returns {Uint8Array|null} - The fragment data or null if not found
     */
    getFragment(trackId, segmentId) {
        const trackType = trackId === 0 ? "video" : "audio";
        
        // For initialization segments
        if (segmentId === 0 || segmentId === -1) {
            return this.init[trackType];
        }
        
        // For media segments
        const buffer = this.buffer[trackType];
        
        // Try to find exact segment ID
        if (buffer[segmentId]) {
            return buffer[segmentId];
        }
        
        // If not found, get closest segment ID
        const keys = Object.keys(buffer).map(Number).sort((a, b) => a - b);
        
        // Find closest segment (prefer newer segments)
        if (keys.length > 0) {
            // Sort by closeness to the requested segment ID
            keys.sort((a, b) => Math.abs(a - segmentId) - Math.abs(b - segmentId));
            const closestId = keys[0];
            
            log(`‚ö†Ô∏è Segment #${segmentId} not found, using closest #${closestId}`);
            return buffer[closestId];
        }
        
        return null;
    }
    
    /**
     * Get statistics about buffer state
     * 
     * @returns {object} - Statistics
     */
    getStats() {
        const videoFragCount = Object.keys(this.buffer.video).length;
        const audioFragCount = Object.keys(this.buffer.audio).length;
        
        return {
            bytesReceived: this.bytesReceived,
            audioFragments: audioFragCount,
            videoFragments: videoFragCount,
            fragmentsReceived: this.fragmentsReceived,
            fragmentsAvailable: videoFragCount + audioFragCount,
            packetsReceived: this.wmpPacketsReceived,
            videoInitAvailable: this.init.video !== null,
            audioInitAvailable: this.init.audio !== null,
            mpdAvailable: this.mpdData !== null
        };
    }
    
    /**
     * Clean up resources before disconnection
     */
    disconnect() {
        this.isDisconnected = true;
        log(`üßπ Cleaning up packet handler resources`);
        
        // Clear buffers
        this.buffer.video = {};
        this.buffer.audio = {};
        
        // Clear track-specific buffers
        Object.keys(this.trackBuffers).forEach(trackId => {
            this.trackBuffers[trackId].fragments = [];
        });
        
        // Clear MPD data
        if (this.mpdUrl && this.mpdUrl.startsWith('blob:')) {
            try {
                URL.revokeObjectURL(this.mpdUrl);
            } catch (e) {
                // Ignore errors during cleanup
            }
        }
        
        this.mpdData = null;
        this.mpdUrl = '/vivoh.mpd';
        
        // Clear initialization segments
        this.init.video = null;
        this.init.audio = null;
    }
}

function isInitSegment(data) {
    // Must have enough data for basic check
    if (!data || data.byteLength < 12) return false;
    
    try {
        // Check for ftyp box which is typically at the start of an init segment
        const possibleFtyp = new TextDecoder().decode(data.slice(4, 8));
        if (possibleFtyp === 'ftyp') return true;
        
        // Check for moov box which is essential in an init segment
        // We'll scan the first 100 bytes for it as it might not be right at the start
        for (let i = 0; i < Math.min(data.byteLength - 8, 100); i += 4) {
            const possibleBox = new TextDecoder().decode(data.slice(i + 4, i + 8));
            if (possibleBox === 'moov') return true;
        }
    } catch (e) {
        // If any parsing error occurs, assume it's not an init segment
        log(`‚ö†Ô∏è Error checking for init segment: ${e.message}`);
    }
    
    return false;
}

/**
 * Log detailed media state information for debugging
 */
 function debugMediaState() {
    log(`üîç DEBUG: Starting media state diagnosis`);
    
    // Check if packetHandler exists
    if (!window.packetHandler) {
        log(`‚ö†Ô∏è No packetHandler available for debugging`);
        log(`üîç Connection status: ${window.transport ? "Connected" : "Not connected"}`);
        log(`üîç Player exists: ${window.player ? "Yes" : "No"}`);
        log(`üîç Player state: ${window.playerState || "Unknown"}`);
        
        // Suggest establishing connection first
        log(`üí° Try connecting to the server first before debugging media`);
        return;
    }
    
    // Check packet and fragment counts
    const stats = window.packetHandler.getStats();
    log(`üìä Media Debug: WMP Packets received: ${stats.packetsReceived}`);
    log(`üìä Fragments: Video=${stats.videoFragments}, Audio=${stats.audioFragments}`);
    log(`üìä Init segments: Video=${stats.videoInitAvailable ? "Yes" : "No"}, Audio=${stats.audioInitAvailable ? "Yes" : "No"}`);
    log(`üìä MPD available: ${stats.mpdAvailable ? "Yes" : "No"}`);
    
    // Check init segments
    checkInitSegments();
    
    // Check fragments
    checkFragmentMetadata();
    
    // Check player state
    if (window.player) {
        const videoElement = document.getElementById('videoElement');
        const readyState = videoElement.readyState;
        const readyStateText = ["HAVE_NOTHING", "HAVE_METADATA", "HAVE_CURRENT_DATA", "HAVE_FUTURE_DATA", "HAVE_ENOUGH_DATA"][readyState] || "Unknown";
        
        log(`üìä Player exists, video element readyState=${readyState} (${readyStateText})`);
        log(`üìä Player state: ${window.playerState || "Unknown"}`);
        log(`üìä Video paused: ${videoElement.paused}, Video seeking: ${videoElement.seeking}`);
        log(`üìä Video current time: ${videoElement.currentTime.toFixed(2)}s`);
        
        try {
            // Try to get DASH.js internal buffer levels
            const videoBufferLevel = window.player.getBufferLength("video") || 0;
            const audioBufferLevel = window.player.getBufferLength("audio") || 0;
            log(`üìä DASH.js buffer levels: Video=${videoBufferLevel.toFixed(2)}s, Audio=${audioBufferLevel.toFixed(2)}s`);
        } catch (e) {
            log(`‚ö†Ô∏è Could not get DASH.js buffer levels: ${e.message}`);
        }
    } else {
        log(`üìä Player does not exist yet`);
    }
}

/**
 * Check initialization segments
 */
function checkInitSegments() {
    if (!window.packetHandler) {
        log(`‚ùå No packet handler available`);
        return;
    }
    
    ["video", "audio"].forEach(trackType => {
        const init = window.packetHandler.init[trackType];
        if (!init) {
            log(`‚ùå No init segment for ${trackType}`);
            return;
        }
        
        // Check for mvex box (required for DASH)
        let foundMvex = false;
        let foundMoov = false;
        
        for (let i = 0; i < Math.min(init.length - 8, 2000); i++) {
            if (i + 8 <= init.length) {
                const boxTypeAtPos = String.fromCharCode(
                    init[i + 4], init[i + 5], init[i + 6], init[i + 7]
                );
                
                if (boxTypeAtPos === 'mvex') {
                    foundMvex = true;
                }
                
                if (boxTypeAtPos === 'moov') {
                    foundMoov = true;
                }
            }
        }
        
        log(`üß™ ${trackType} init segment: ${init.length} bytes, moov=${foundMoov}, mvex=${foundMvex}`);
        
        if (!foundMvex) {
            log(`‚ö†Ô∏è WARNING: ${trackType} init segment missing mvex box, DASH playback may fail!`);
        }
    });
}

/**
 * Check fragment metadata
 */
function checkFragmentMetadata() {
    if (!window.packetHandler) {
        log(`‚ùå No packet handler available`);
        return;
    }
    
    ["video", "audio"].forEach(trackType => {
        const buffer = window.packetHandler.buffer[trackType];
        const fragmentIds = Object.keys(buffer).sort((a, b) => parseInt(a) - parseInt(b));
        
        let hasMoofCount = 0;
        
        fragmentIds.forEach(id => {
            const data = buffer[id];
            
            // Check for moof box which is essential in a media fragment
            let hasMoof = false;
            for (let i = 0; i < Math.min(data.length - 8, 100); i += 4) {
                if (i + 8 <= data.length) {
                    const boxTypeAtPos = String.fromCharCode(
                        data[i + 4], data[i + 5], data[i + 6], data[i + 7]
                    );
                    
                    if (boxTypeAtPos === 'moof') {
                        hasMoof = true;
                        hasMoofCount++;
                        break;
                    }
                }
            }
            
            // Log details for some fragments
            if (parseInt(id) % 10 === 0) {
                log(`  ${trackType} #${id}: ${data.length} bytes, moof=${hasMoof}`);
            }
        });
        
        log(`üìä ${trackType}: ${fragmentIds.length} fragments, ${hasMoofCount} with moof boxes (${Math.round(hasMoofCount/Math.max(fragmentIds.length, 1)*100)}%)`);
    });
}

/**
 * Check the WebTransport connection status
 */
function checkConnectionStatus() {
    if (!window.transport) {
        log(`‚ö†Ô∏è No active WebTransport connection`);
        return false;
    }
    
    try {
        // For WebTransport, check if we have any active readers
        if (window.activeReaders && window.activeReaders.length > 0) {
            log(`‚úÖ WebTransport connection has ${window.activeReaders.length} active readers`);
            return true;
        }
        
        // Try to create a datagram writer as a test
        const writer = window.transport.datagrams?.writable?.getWriter();
        if (writer) {
            writer.releaseLock();
            log(`‚úÖ WebTransport connection appears active (datagram test passed)`);
            return true;
        }
        
        log(`‚ö†Ô∏è WebTransport connection exists but may be inactive`);
        return false;
    } catch (e) {
        log(`‚ùå WebTransport connection test failed: ${e.message}`);
        return false;
    }
}

const initCache = {
  "init_0.mp4": null,
  "init_1.mp4": null,
};

function respond404() {
    return new Response("Segment not found", { status: 404 });
}

function respond(data) {
    return new Response(data, {
        status: 200,
        headers: {
            "Content-Type": "video/mp4",
        },
    });
}

function handleSegmentRequest(url) {
  // Use packetHandler's init segments instead of undefined variables
  if (url.endsWith("init_0.mp4")) {
    if (initCache["init_0.mp4"]) return respond(initCache["init_0.mp4"]);
    if (window.packetHandler && window.packetHandler.init.video) {
      initCache["init_0.mp4"] = window.packetHandler.init.video;
      return respond(window.packetHandler.init.video);
    }
    return respond404();
  }
  
  if (url.endsWith("init_1.mp4")) {
    if (initCache["init_1.mp4"]) return respond(initCache["init_1.mp4"]);
    if (window.packetHandler && window.packetHandler.init.audio) {
      initCache["init_1.mp4"] = window.packetHandler.init.audio;
      return respond(window.packetHandler.init.audio);
    }
    return respond404();
  }

  // Improved media segment handling
  if (url.match(/chunk_\d+_\d+\.m4s/)) {
    const match = url.match(/chunk_(\d+)_(\d+)\.m4s/);
    if (match && window.packetHandler) {
      const trackId = parseInt(match[1]);
      const segmentId = parseInt(match[2]);
      
      const trackType = trackId === 0 ? 'video' : 'audio';
      const buffer = window.packetHandler.buffer[trackType];
      
      if (buffer && buffer[segmentId]) {
        log(`üé¨ Serving exact segment: track=${trackId}, id=${segmentId}`);
        return respond(buffer[segmentId]);
      }
      
      // Try to find closest segment
      const keys = Object.keys(buffer || {}).map(Number).sort((a, b) => a - b);
      const next = keys.find(k => k > segmentId);

      if (next && Math.abs(next - segmentId) < 100) {
        log(`üé¨ Segment #${segmentId} not found, using next #${next}`);
        return respond(buffer[next]);
      }

      const latest = keys[keys.length - 1];
      if (latest && latest > segmentId) {
        log(`üé¨ Using latest segment #${latest} instead of #${segmentId}`);
        return respond(buffer[latest]);
      }
    }
    
    log(`‚ö†Ô∏è Segment not found for URL: ${url}`);
    return respond404();
  }

  return respond404();
}

function extractSegmentId(url) {
    const match = url.match(/chunk_\d+_(\d+)\.m4s/);
    return match ? parseInt(match[1], 10) : NaN;
}

/**
 * Set up XHR interception to serve media content from our buffer
 */
 function setupXHRInterception() {
  if (window.xhrInterceptionEnabled) return;
  
  log("üîÑ Setting up XMLHttpRequest interception");
  window.xhrInterceptionEnabled = true;
  
  const originalXHROpen = XMLHttpRequest.prototype.open;
  const originalXHRSend = XMLHttpRequest.prototype.send;
  
  // Create a map to store blob URLs and their corresponding data
  const blobUrlMap = new Map();
  
  // Add method to register MPD blob URLs
  window.registerMpdBlobUrl = (url, mpdData) => {
    blobUrlMap.set(url, mpdData);
    log(`üìÑ Registered MPD blob URL: ${url}`);
  };
  
  // Add method to register media segments
  window.registerMediaSegment = (trackId, segmentId, data) => {
    const key = `segment-${trackId}-${segmentId}`;
    blobUrlMap.set(key, data);
  };
  
  // Log all XHR requests to debug
  XMLHttpRequest.prototype.open = function(method, url, async) {
    this._url = url;
    this._method = method;
    
    if (method === 'GET' && typeof url === 'string') {
      log(`üîç XHR Request: ${method} ${url}`);
    }
    
    // Track request type
    if (typeof url === 'string') {
      // Check if this is a blob URL that we've registered
      if (url.startsWith('blob:') && blobUrlMap.has(url)) {
        this._isMpdBlobUrl = true;
        log(`üìÑ Recognized registered MPD blob URL: ${url}`);
      }
      // Standard MPD requests
      else if (url.includes('.mpd')) {
        this._isMPDRequest = true;
        log(`üìÑ MPD request detected: ${url}`);
      } 
      // Init segment requests
      else if (url.includes('init_')) {
        this._isInitSegment = true;
        const match = url.match(/init_(\d+)\.mp4/);
        if (match) {
          this._trackId = parseInt(match[1]);
          log(`üîë Init segment request for track ${this._trackId}`);
        }
      } 
      // Media segment requests
      else if (url.match(/chunk_\d+_\d+\.m4s/) || url.match(/chunk-\d+-\d+\.m4s/)) {
        this._isMediaSegment = true;
        let match = url.match(/chunk_(\d+)_(\d+)\.m4s/);
        if (!match) {
          match = url.match(/chunk-(\d+)-(\d+)\.m4s/);
        }
        
        if (match) {
          this._trackId = parseInt(match[1]);
          this._segmentId = parseInt(match[2]);
          log(`üé¨ Media segment request: track=${this._trackId}, segment=${this._segmentId}`);
        }
      }
      // External requests - don't try to intercept these
      else if (url.includes('time.akamai.com') || url.includes('/api/')) {
        this._isExternalRequest = true;
      }
    }
    
    originalXHROpen.call(this, method, url, async !== false);
  };
  
  XMLHttpRequest.prototype.send = function(body) {
    // External requests - always pass through
    if (this._isExternalRequest) {
      originalXHRSend.call(this, body);
      return;
    }
    
    // MPD Blob URL Request - serve from our map
    if (this._isMpdBlobUrl && blobUrlMap.has(this._url)) {
      log(`üìÑ Serving registered MPD blob from map (${this._url})`);
      
      const mpdData = blobUrlMap.get(this._url);
      
      setTimeout(() => {
        this.responseType = 'text';
        Object.defineProperty(this, 'response', { get: () => mpdData });
        Object.defineProperty(this, 'responseText', { get: () => mpdData });
        Object.defineProperty(this, 'status', { get: () => 200 });
        Object.defineProperty(this, 'statusText', { get: () => 'OK' });
        Object.defineProperty(this, 'readyState', { get: () => 4 });
        
        this.dispatchEvent(new Event('readystatechange'));
        this.dispatchEvent(new Event('load'));
        this.dispatchEvent(new Event('loadend'));
        
        log(`‚úÖ Blob MPD served successfully`);
      }, 10);
      
      return;
    }
    
    // Standard MPD Request
    if (this._isMPDRequest && window.packetHandler?.mpdData) {
      log(`üìÑ Serving MPD from WebTransport packet (${window.packetHandler.mpdData.length} bytes)`);
      
      setTimeout(() => {
        this.responseType = 'text';
        Object.defineProperty(this, 'response', { get: () => window.packetHandler.mpdData });
        Object.defineProperty(this, 'responseText', { get: () => window.packetHandler.mpdData });
        Object.defineProperty(this, 'status', { get: () => 200 });
        Object.defineProperty(this, 'statusText', { get: () => 'OK' });
        Object.defineProperty(this, 'readyState', { get: () => 4 });
        
        this.dispatchEvent(new Event('readystatechange'));
        this.dispatchEvent(new Event('load'));
        this.dispatchEvent(new Event('loadend'));
        
        log(`‚úÖ MPD served successfully`);
      }, 10);
      
      return;
    }
    
    // Init Segment Request
    if (this._isInitSegment && typeof this._trackId !== 'undefined') {
      const trackId = this._trackId;
      const trackType = trackId === 0 ? "video" : "audio";
      
      // Check if we have an init segment for this track
      if (window.packetHandler?.init[trackType]) {
        const initData = window.packetHandler.init[trackType];
        log(`üîë Serving ${trackType} init segment (${initData.byteLength} bytes)`);
        
        setTimeout(() => {
          // IMPORTANT: Ensure we're using the correct responseType
          this.responseType = 'arraybuffer';
          
          // Make sure we're serving an ArrayBuffer, not a TypedArray
          let buffer;
          if (initData instanceof Uint8Array) {
            buffer = initData.buffer.slice(
              initData.byteOffset, 
              initData.byteOffset + initData.byteLength
            );
          } else {
            buffer = initData;
          }
          
          // Set the correct response properties
          Object.defineProperty(this, 'response', { get: () => buffer });
          Object.defineProperty(this, 'status', { get: () => 200 });
          Object.defineProperty(this, 'statusText', { get: () => 'OK' });
          Object.defineProperty(this, 'readyState', { get: () => 4 });
          
          // Add debugging to verify data is valid
          const firstBytes = new Uint8Array(buffer.slice(0, Math.min(16, buffer.byteLength)));
          log(`üîç Init segment first bytes: ${Array.from(firstBytes).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
          
          // Dispatch events to signal completion
          this.dispatchEvent(new Event('readystatechange'));
          this.dispatchEvent(new Event('load'));
          this.dispatchEvent(new Event('loadend'));
          
          log(`‚úÖ Init segment served: track=${trackId}`);
        }, 10);
        
        return;
      } else {
        log(`‚ö†Ô∏è No init segment available for track ${trackId}`);
      }
    }
    
    // Media Segment Request - IMPROVED VERSION
    if (this._isMediaSegment && typeof this._trackId !== 'undefined' && typeof this._segmentId !== 'undefined') {
      const trackId = this._trackId;
      const segmentId = this._segmentId;
      const trackType = trackId === 0 ? "video" : "audio";
      
      // Try to get segment from packetHandler
      let segmentData = null;
      
      // First check if exact segment exists in buffer
      if (window.packetHandler && window.packetHandler.buffer[trackType][segmentId]) {
        segmentData = window.packetHandler.buffer[trackType][segmentId];
        log(`üé¨ Found exact segment: track=${trackId}, segment=${segmentId}`);
      } 
      // If not, try to find a segment close to the requested one
      else if (window.packetHandler) {
        const buffer = window.packetHandler.buffer[trackType];
        const keys = Object.keys(buffer).map(Number).sort((a, b) => a - b);
        
        if (keys.length > 0) {
          // Try to find closest segment - better to use newer segments
          const closerKeys = keys.filter(k => Math.abs(k - segmentId) < 10);
          
          if (closerKeys.length > 0) {
            const closestId = closerKeys.sort((a, b) => Math.abs(a - segmentId) - Math.abs(b - segmentId))[0];
            log(`üîÑ Using closest segment: ${trackType} #${closestId} instead of #${segmentId}`);
            segmentData = buffer[closestId];
          } else {
            // Default to most recent segment
            const latestKey = keys[keys.length - 1];
            log(`üîÑ Using latest segment: ${trackType} #${latestKey} instead of #${segmentId}`);
            segmentData = buffer[latestKey];
          }
        }
      }
      
      if (segmentData) {
        log(`üé¨ Serving segment: track=${trackId}, segment=${segmentId} (${segmentData.byteLength} bytes)`);
        
        setTimeout(() => {
          // IMPORTANT: Ensure using correct responseType
          this.responseType = 'arraybuffer';
          
          // Make sure we're serving an ArrayBuffer, not a TypedArray
          let buffer;
          if (segmentData instanceof Uint8Array) {
            buffer = segmentData.buffer.slice(
              segmentData.byteOffset, 
              segmentData.byteOffset + segmentData.byteLength
            );
          } else {
            buffer = segmentData;
          }
          
          // Set the correct response properties with proper content type
          Object.defineProperty(this, 'response', { get: () => buffer });
          Object.defineProperty(this, 'status', { get: () => 200 });
          Object.defineProperty(this, 'statusText', { get: () => 'OK' });
          Object.defineProperty(this, 'readyState', { get: () => 4 });
          
          // Add debugging to verify data
          const firstBytes = new Uint8Array(buffer.slice(0, Math.min(16, buffer.byteLength)));
          log(`üîç Media segment first bytes: ${Array.from(firstBytes).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
          
          // Validate segment contains moof/mdat boxes (required for MSE)
          let hasMoof = false;
          let hasMdat = false;
          const u8Data = new Uint8Array(buffer);
          
          // Check for moof and mdat boxes in the first 100 bytes
          for (let i = 0; i < Math.min(u8Data.length - 8, 100); i += 4) {
            if (i + 8 <= u8Data.length) {
              const boxType = String.fromCharCode(
                u8Data[i + 4], u8Data[i + 5], u8Data[i + 6], u8Data[i + 7]
              );
              
              if (boxType === 'moof') hasMoof = true;
              if (boxType === 'mdat') hasMdat = true;
            }
          }
          
          log(`üé¨ Media validation: track=${trackId}, segment=${segmentId}, hasMoof=${hasMoof}, hasMdat=${hasMdat}`);
          
          // Dispatch events to signal completion
          this.dispatchEvent(new Event('readystatechange'));
          this.dispatchEvent(new Event('load'));
          this.dispatchEvent(new Event('loadend'));
          
          log(`‚úÖ Media segment served: track=${trackId}, segment=${segmentId}`);
        }, 10);
        
        return;
      } else {
        log(`‚ö†Ô∏è No media segment available for track=${trackId}, segment=${segmentId}`);
        // Respond with 404 to allow DASH.js to retry
        setTimeout(() => {
          Object.defineProperty(this, 'status', { get: () => 404 });
          Object.defineProperty(this, 'statusText', { get: () => 'Not Found' });
          Object.defineProperty(this, 'readyState', { get: () => 4 });
          
          this.dispatchEvent(new Event('readystatechange'));
          this.dispatchEvent(new Event('load'));
          this.dispatchEvent(new Event('loadend'));
        }, 10);
        
        return;
      }
    }
    
    // Fall back to original XHR behavior for any unhandled requests
    originalXHRSend.call(this, body);
  };
  
  log(`‚úÖ Enhanced XHR interception setup completed`);
  return true;
}

function updateUI() {
    // Get UI elements
    const connStatus = document.getElementById('connectionStatus');
    const bufferStatus = document.getElementById('bufferStatus');
    const playerStatus = document.getElementById('playerStatus');
    const connectBtn = document.getElementById('connectButton');
    const playBtn = document.getElementById('playButton');
    const disconnectBtn = document.getElementById('disconnectButton');
    const packetCounter = document.getElementById('packetCounter');
    const streamCounter = document.getElementById('streamCounter');
    
    // ===== Connection status =====
    if (transport) {
        connStatus.textContent = 'Connected';
        connStatus.className = 'status-badge status-connected';
        connectBtn.disabled = true;
        disconnectBtn.disabled = false;
    } else {
        connStatus.textContent = 'Disconnected';
        connStatus.className = 'status-badge status-disconnected';
        connectBtn.disabled = false;
        disconnectBtn.disabled = true;
    }
    
    // ===== DASH Fragments status =====
    if (window.packetHandler) {
        const stats = window.packetHandler.getStats();
        const audioCount = stats.audioFragments || 0;
        const videoCount = stats.videoFragments || 0;
        
        bufferStatus.textContent = `${audioCount + videoCount} (A:${audioCount}, V:${videoCount})`;
        
        if (audioCount + videoCount > 0) {
            bufferStatus.className = 'status-badge status-connected';
        } else {
            bufferStatus.className = 'status-badge';
        }
        
        // Update media packets counter
        if (packetCounter) {
            packetCounter.textContent = stats.packetsReceived || 0;
            if (stats.packetsReceived > 0) {
                packetCounter.className = 'status-badge status-connected';
            } else {
                packetCounter.className = 'status-badge';
            }
        }
    } else {
        bufferStatus.textContent = '0 (A:0, V:0)';
        bufferStatus.className = 'status-badge';
        
        if (packetCounter) {
            packetCounter.textContent = '0';
            packetCounter.className = 'status-badge';
        }
    }
    
    // ===== Player status =====
    playerStatus.textContent = window.playerState.charAt(0).toUpperCase() + window.playerState.slice(1);
    
    if (window.playerState === 'buffering') {
        playerStatus.className = 'status-badge status-buffering';
    } else if (window.playerState === 'playing') {
        playerStatus.className = 'status-badge status-connected';
    } else if (window.playerState === 'error') {
        playerStatus.className = 'status-badge status-disconnected';
    } else {
        playerStatus.className = 'status-badge';
    }
    
    // ===== QUIC Streams counter =====
    if (streamCounter) {
        streamCounter.textContent = window.streamCounter || 0;
        if (window.streamCounter > 0) {
            streamCounter.className = 'status-badge status-connected';
        } else {
            streamCounter.className = 'status-badge';
        }
    }
    
    // ===== Play button state =====
    if (window.player) {
        // Enable play button if player exists and isn't currently playing
        playBtn.disabled = (window.playerState === 'playing' || window.playerState === 'buffering');
    } else {
        // Disable play button if player doesn't exist
        playBtn.disabled = true;
    }
}

// Enhanced player logging
function logPlayerEvent(event, data) {
  const message = `üé¨ Player Event [${event}]: ${JSON.stringify(data || {})}`;
  log(message);
}

// Add more detailed buffer logging
function logBufferState() {
  if (!player) return;
  
  try {
    const videoBuffer = player.getBufferLength('video');
    const audioBuffer = player.getBufferLength('audio');
    const quality = player.getQualityFor('video');
    const bandwidth = player.getBandwidthEstimate();
    
    log(`üìä Buffer: Video=${videoBuffer.toFixed(2)}s, Audio=${audioBuffer.toFixed(2)}s, Quality=${quality}, BW=${(bandwidth/1000).toFixed(0)}kbps`);
  } catch (e) {
    log(`‚ö†Ô∏è Error getting buffer info: ${e.message}`);
  }
}

// Enhanced player debugging
function logPlayerDebugInfo() {
  if (!player) return;
  
  try {
    const videoTrackInfo = player.getCurrentTrackFor('video');
    const audioTrackInfo = player.getCurrentTrackFor('audio');
    
    log(`üîç Video Track: ${JSON.stringify(videoTrackInfo)}`);
    log(`üîç Audio Track: ${JSON.stringify(audioTrackInfo)}`);
    
    // Get active stream info
    const activeStream = player.getActiveStream();
    if (activeStream) {
      log(`üîç Active Stream ID: ${activeStream.getId()}`);
    }
    
    // Get adaptation set info
    const streamInfo = player.getStreamInfo();
    if (streamInfo) {
      log(`üîç Stream Period ID: ${streamInfo.id}`);
      const videoAdaptation = player.getAdaptationForType(streamInfo.id, 'video');
      const audioAdaptation = player.getAdaptationForType(streamInfo.id, 'audio');
      
      if (videoAdaptation) {
        log(`üîç Video Adaptation: ${JSON.stringify(videoAdaptation.id)}`);
      }
      
      if (audioAdaptation) {
        log(`üîç Audio Adaptation: ${JSON.stringify(audioAdaptation.id)}`);
      }
    }
  } catch (e) {
    log(`‚ö†Ô∏è Error getting debug info: ${e.message}`);
  }
}

// Helper to check if data already has MP4 structure
function hasMP4Structure(data) {
  try {
    // Need at least 8 bytes to check box type
    if (data.byteLength < 8) return false;
    
    // Check for common MP4 boxes
    const boxType = new TextDecoder().decode(data.slice(4, 8));
    if (boxType === 'moof' || boxType === 'styp' || boxType === 'sidx') {
      return true;
    }
    
    // Check for secondary boxes
    if (data.byteLength >= 16) {
      const secondBoxOffset = new DataView(data.buffer, data.byteOffset, 4).getUint32(0);
      if (secondBoxOffset < data.byteLength - 8) {
        const secondBoxType = new TextDecoder().decode(data.slice(secondBoxOffset + 4, secondBoxOffset + 8));
        if (secondBoxType === 'mdat' || secondBoxType === 'moof') {
          return true;
        }
      }
    }
    
    return false;
  } catch (e) {
    log(`‚ö†Ô∏è Error checking MP4 structure: ${e.message}`);
    return false;
  }
}

function createSyntheticInitSegment(trackId) {
  const isVideo = trackId === 0;
  
  // Basic structure for a minimal MP4 initialization segment
  const videoInit = new Uint8Array([
    // ftyp box
    0x00, 0x00, 0x00, 0x18, 0x66, 0x74, 0x79, 0x70, 0x69, 0x73, 0x6f, 0x6d, 
    0x00, 0x00, 0x00, 0x01, 0x69, 0x73, 0x6f, 0x6d, 0x61, 0x76, 0x63, 0x31,
    
    // moov box (simplified)
    0x00, 0x00, 0x00, 0x6c, 0x6d, 0x6f, 0x6f, 0x76, 
    
    // mvhd box (simplified)
    0x00, 0x00, 0x00, 0x6c, 0x6d, 0x76, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x00, 0x00,
    
    // trak box (simplified)
    0x00, 0x00, 0x00, 0x5c, 0x74, 0x72, 0x61, 0x6b, 
    
    // tkhd box (simplified)
    0x00, 0x00, 0x00, 0x5c, 0x74, 0x6b, 0x68, 0x64, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // mdia box with minimal info (simplified)
    0x00, 0x00, 0x00, 0x20, 0x6d, 0x64, 0x69, 0x61,
    0x00, 0x00, 0x00, 0x20, 0x6d, 0x64, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xc4, 0x00, 0x00
  ]);
  
  const audioInit = new Uint8Array([
    // ftyp box
    0x00, 0x00, 0x00, 0x18, 0x66, 0x74, 0x79, 0x70, 0x69, 0x73, 0x6f, 0x6d, 
    0x00, 0x00, 0x00, 0x01, 0x69, 0x73, 0x6f, 0x6d, 0x61, 0x76, 0x63, 0x31,
    
    // moov box (simplified)
    0x00, 0x00, 0x00, 0x6c, 0x6d, 0x6f, 0x6f, 0x76, 
    
    // mvhd box (simplified)
    0x00, 0x00, 0x00, 0x6c, 0x6d, 0x76, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x00, 0x00,
    
    // trak box (simplified)
    0x00, 0x00, 0x00, 0x5c, 0x74, 0x72, 0x61, 0x6b, 
    
    // tkhd box (simplified)
    0x00, 0x00, 0x00, 0x5c, 0x74, 0x6b, 0x68, 0x64, 0x00, 0x00, 0x00, 0x02,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // mdia box with minimal info (simplified)
    0x00, 0x00, 0x00, 0x20, 0x6d, 0x64, 0x69, 0x61,
    0x00, 0x00, 0x00, 0x20, 0x6d, 0x64, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBB, 0x80, 0x00, 0x00
  ]);
  
  // Return the appropriate init segment based on track ID
  log(`üîß Created synthetic init segment for ${isVideo ? "video" : "audio"} track`);
  return isVideo ? videoInit : audioInit;
}

/**
 * Setup WebTransport connection and handlers
 * 
 * @param {string} url - WebTransport server URL
 * @returns {WebTransportMediaPacketHandler} - The packet handler
 */
 async function setupWebTransport(url) {
  try {
    window.disconnectionRequested = false;
    
    log(`üîç Setting up WebTransport with URL: ${url}`);
    
    // Clear any existing resources
    if (window.transport) {
      try { 
        window.transport.close(); 
      } catch (e) {
        log(`üîç Error closing existing transport: ${e.message}`);
      }
      window.transport = null;
    }
    
    // Initialize packet handler
    window.packetHandler = new WebTransportMediaPacketHandler();
    
    // Set MPD ready callback to initialize player
    window.packetHandler.onMpdReady = (mpdUrl) => {
      log(`üìÑ MPD ready for playback: ${mpdUrl}`);
      setupDashPlayer(mpdUrl);
    };
    
    // Setup XHR interception BEFORE creating WebTransport connection
    setupXHRInterception();
    
    // Connect to WebTransport 
    log(`üîó Connecting to WebTransport server: ${url}`);
    
    const createStartTime = Date.now();
    window.transport = new WebTransport(url);
    const createEndTime = Date.now();
    
    log(`üì° WebTransport object created in ${createEndTime - createStartTime}ms`);
    
    // Set up connection closed handler
    window.transport.closed.then(() => {
      log(`‚ÑπÔ∏è Connection closed normally`);
      if (!window.disconnectionRequested) {
        handleConnectionClosed();
      }
    }).catch((error) => {
      log(`‚ùå Connection closed with error: ${error.message}`);
      if (!window.disconnectionRequested) {
        handleConnectionClosed();
      }
    });
    
    // Listen for incoming streams
    listenToIncomingStreams(window.transport, window.packetHandler).catch(err => {
      log(`‚ùå Error in stream listener: ${err.message}`);
    });
    
    // Start status updates
    startStatusUpdates();
    
    // Update UI
    updateUI();
    
    log(`‚úÖ WebTransport setup completed successfully`);
    
    return window.packetHandler;
  } catch (error) {
    log(`‚ùå WebTransport error: ${error.message}`);
    updateUI();
    throw error;
  }
}

/**
 * Start periodic status updates
 */
function startStatusUpdates() {
    // Clear any existing interval
    if (window.statusInterval) {
        clearInterval(window.statusInterval);
    }
    
    window.statusInterval = setInterval(() => {
        // Skip if disconnected
        if (window.disconnectionRequested || !window.transport) {
            clearInterval(window.statusInterval);
            window.statusInterval = null;
            return;
        }
        
        // Log buffer status periodically
        if (window.packetHandler) {
            const stats = window.packetHandler.getStats();
            log(`üìä Status: ${stats.packetsReceived} packets, ${stats.fragmentsAvailable} fragments (Audio:${stats.audioFragments}, Video:${stats.videoFragments}), Streams:${window.streamCounter || 0}`);
        }
        
        // Update the UI
        updateUI();
        
    }, 5000); // Update every 5 seconds
    
    // Ensure the UI is updated immediately as well
    updateUI();
}

/**
 * Disconnect WebTransport and clean up resources
 */
function disconnectWebTransport() {
    log("‚èπÔ∏è Disconnect requested");
    window.disconnectionRequested = true;
    
    // Clean up resources
    if (window.statusInterval) {
        clearInterval(window.statusInterval);
        window.statusInterval = null;
    }
    
    const bufferLoggingIntervals = window.bufferLoggingIntervals || [];
    bufferLoggingIntervals.forEach(interval => clearInterval(interval));
    window.bufferLoggingIntervals = [];
    
    // Cancel all active readers
    const activeReaders = window.activeReaders || [];
    activeReaders.forEach(reader => {
        try { reader.cancel().catch(() => {}); } catch (e) {}
    });
    window.activeReaders = [];
    
    // Close transport connection
    if (window.transport) {
        window.transport.close();
        window.transport = null;
    }
    
    // Clean up packet handler and player
    if (window.packetHandler) {
        window.packetHandler.disconnect();
        window.packetHandler = null;
    }
    
    if (window.player) {
        try {
            window.player.reset();
        } catch (e) {}
        window.player = null;
    }
    
    // Reset all counters
    window.playerState = 'idle';
    window.streamCounter = 0;
    
    // Update UI to reflect disconnect
    updateUI();
    
    // Reset counters in UI directly (in case updateUI doesn't handle it)
    const packetCounter = document.getElementById('packetCounter');
    if (packetCounter) {
        packetCounter.textContent = '0';
        packetCounter.className = 'status-badge';
    }
    
    const streamCounter = document.getElementById('streamCounter');
    if (streamCounter) {
        streamCounter.textContent = '0';
        streamCounter.className = 'status-badge';
    }
    
    const bufferStatus = document.getElementById('bufferStatus');
    if (bufferStatus) {
        bufferStatus.textContent = '0 (A:0, V:0)';
        bufferStatus.className = 'status-badge';
    }
}

/**
 * Handle connection closed by server
 */
function handleConnectionClosed() {
    if (window.disconnectionRequested) return; // Don't log if disconnect was requested
    
    log("‚ùå WebTransport connection closed by server");
    
    // Clean up
    disconnectWebTransport();
    
    // Update UI
    const connStatus = document.getElementById('connectionStatus');
    if (connStatus) {
        connStatus.textContent = 'Disconnected (by server)';
        connStatus.className = 'status-badge status-disconnected';
    }
}

// Function to preload initialization segments from server
async function preloadInitSegments() {
  try {
    log(`üîÑ Preloading initialization segments from server...`);
    
    // Fetch video init segment
    fetch('/init_0.mp4')
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        return response.arrayBuffer();
      })
      .then(buffer => {
        const data = new Uint8Array(buffer);
        log(`‚úÖ Loaded video init segment from server (${data.byteLength} bytes)`);
        
        // Store the init segment in packetHandler
        if (window.packetHandler) {
          window.packetHandler.init.video = data;
        }
      })
      .catch(error => {
        log(`‚ùå Error loading video init segment: ${error.message}`);
      });
    
    // Fetch audio init segment
    fetch('/init_1.mp4')
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        return response.arrayBuffer();
      })
      .then(buffer => {
        const data = new Uint8Array(buffer);
        log(`‚úÖ Loaded audio init segment from server (${data.byteLength} bytes)`);
        
        // Store the init segment in packetHandler
        if (window.packetHandler) {
          window.packetHandler.init.audio = data;
        }
      })
      .catch(error => {
        log(`‚ùå Error loading audio init segment: ${error.message}`);
      });
  } catch (error) {
    log(`‚ùå Error in preloadInitSegments: ${error.message}`);
  }
}

// Helper function to check if we're ready to initialize player
function checkPlayerReadiness() {
  // Check if player already exists
  if (window.player) {
    log(`üé¨ Player already exists, skipping initialization check`);
    return;
  }
  
  // Check if we have enough fragments and init segments
  const hasVideoInit = window.packetHandler && window.packetHandler.init.video;
  const hasAudioInit = window.packetHandler && window.packetHandler.init.audio;
  
  if (hasVideoInit && hasAudioInit) {
    log(`‚úÖ Init segments loaded, ready to initialize player`);
    setupDashPlayer();
  } else {
    log(`‚è≥ Waiting for init segments before initializing player`);
    // Check again in 500ms
    setTimeout(checkPlayerReadiness, 500);
  }
}

async function listenToIncomingStreams(transport, packetHandler) {
    if (!transport || !packetHandler) {
        log("‚ùå Cannot listen to streams: missing transport or packetHandler");
        return;
    }

    log("üéß Listening for incoming unidirectional streams...");
    const streamReader = transport.incomingUnidirectionalStreams.getReader();

    let streamId = 0;

    try {
        while (!disconnectionRequested) {
            const { value: stream, done } = await streamReader.read();

            if (done) {
                log("üì¥ No more incoming streams ‚Äî reader closed");
                break;
            }

            if (!stream || typeof stream.getReader !== 'function') {
                log("‚ö†Ô∏è Received stream that isn't readable ‚Äî skipping");
                continue;
            }

            streamId++;
            window.streamCounter = streamId; // Update global stream counter
            log(`‚úÖ Incoming QUIC stream #${streamId} received`);
            updateUI(); // Update UI to reflect the new stream

            // Process each stream in its own try-catch block to prevent a single stream error
            // from stopping the listener
            processStream(stream, streamId).catch(error => {
                log(`‚ùå Error processing stream #${streamId}: ${error.message}`);
            });
            
            // Check if we're ready to initialize player after getting the first stream
            if (streamId === 1) {
                // Delay check slightly to allow for first packets to be processed
                setTimeout(checkPlayerReadiness, 500);
            }
        }
    } catch (error) {
        log(`‚ùå Error in stream reader: ${error.message}`);
    } finally {
        log(`üì¥ Stream listener exiting`);
        try {
            streamReader.releaseLock();
        } catch (e) {
            // Ignore errors during cleanup
        }
    }
}

/**
 * Process a WebTransport stream with proper chunk buffering
 * 
 * @param {ReadableStream} stream - The WebTransport stream
 * @param {number} streamId - Stream identifier for logging
 */
 async function processStream(stream, streamId) {
    if (!stream || !window.packetHandler || window.disconnectionRequested) {
        log(`‚ö†Ô∏è Cannot process stream #${streamId}: stream or handler unavailable or disconnection requested`);
        return;
    }
    
    log(`üì• Starting to read from stream #${streamId}`);
    
    let reader;
    try {
        reader = stream.getReader();
        window.activeReaders.push(reader);
    } catch (error) {
        log(`‚ùå Error creating reader for stream #${streamId}: ${error.message}`);
        return;
    }
    
    try {
        let totalBytes = 0;
        let chunkCounter = 0;
        let buffer = new Uint8Array(0);
        let expectedPacketSize = 0;
        let headerParsed = false;
        
        while (!window.disconnectionRequested) {
            const { value, done } = await reader.read();
            
            if (done) {
                // Process any remaining data in buffer if it might be complete
                if (buffer.length > 0 && buffer.length >= expectedPacketSize && expectedPacketSize > 0) {
                    try {
                        log(`Processing final buffer of ${buffer.length} bytes (expected size: ${expectedPacketSize})`);
                        window.packetHandler.processWMPPacket(buffer.slice(0, expectedPacketSize));
                    } catch (e) {
                        log(`‚ùå Error processing final buffer: ${e.message}`);
                    }
                }
                
                log(`üì¥ Stream #${streamId} closed (received ${totalBytes} bytes in ${chunkCounter} chunks)`);
                break;
            }
            
            if (!value || value.byteLength === 0) {
                log(`‚ö†Ô∏è Empty chunk received on stream #${streamId}`);
                continue;
            }
            
            chunkCounter++;
            totalBytes += value.byteLength;
            
            // Log periodically to avoid flooding
            if (chunkCounter === 1 || chunkCounter % 20 === 0) {
                log(`üì¶ Stream #${streamId} chunk #${chunkCounter}: ${value.byteLength} bytes (total: ${totalBytes})`);
            }
            
            // Add new chunk to our buffer
            const newBuffer = new Uint8Array(buffer.length + value.length);
            newBuffer.set(buffer);
            newBuffer.set(value, buffer.length);
            buffer = newBuffer;
            
            // Process complete packets from the buffer
            while (buffer.length > 0) {
                // Need at least 36 bytes to read the header (12 bytes) and field lengths (5*4=20 bytes)
                if (buffer.length < 36) {
                    // Not enough data for header, wait for more
                    break;
                }
                
                // If we haven't calculated the expected packet size yet, do it now
                if (!headerParsed) {
                    try {
                        const view = new DataView(buffer.buffer, buffer.byteOffset, buffer.byteLength);
                        
                        // Skip packet ID (4), timestamp (8), and duration (4)
                        const mpegLength = view.getUint32(16);
                        const audioInitLength = view.getUint32(20);
                        const videoInitLength = view.getUint32(24);
                        const audioDataLength = view.getUint32(28);
                        const videoDataLength = view.getUint32(32);
                        
                        // Calculate total expected packet size
                        expectedPacketSize = 36 + mpegLength + audioInitLength + videoInitLength + 
                                           audioDataLength + videoDataLength;
                        
                        headerParsed = true;
                        
                        // Debug log the expected sizes
                        if (chunkCounter % 10 === 0 || chunkCounter === 1) {
                            log(`üìä Expected packet size: ${expectedPacketSize} bytes`);
                            log(`üìä Field sizes: MPD=${mpegLength}, AudioInit=${audioInitLength}, VideoInit=${videoInitLength}, AudioData=${audioDataLength}, VideoData=${videoDataLength}`);
                        }
                        
                        // Sanity check - if any field size is unreasonably large, it's likely corrupted
                        const MAX_REASONABLE_SIZE = 10 * 1024 * 1024; // 10MB
                        if (expectedPacketSize > MAX_REASONABLE_SIZE || 
                            mpegLength > MAX_REASONABLE_SIZE || 
                            audioInitLength > MAX_REASONABLE_SIZE ||
                            videoInitLength > MAX_REASONABLE_SIZE ||
                            audioDataLength > MAX_REASONABLE_SIZE ||
                            videoDataLength > MAX_REASONABLE_SIZE) {
                            log(`‚ö†Ô∏è Unreasonable packet size detected (${expectedPacketSize} bytes). Corrupted header?`);
                            
                            // Attempt to recover by looking for a valid header pattern
                            let validHeaderFound = false;
                            
                            // Skip this byte and try next position (sliding window approach)
                            for (let i = 1; i < buffer.length - 36; i++) {
                                // Try to find a reasonable header at this offset
                                try {
                                    const offsetView = new DataView(buffer.buffer, buffer.byteOffset + i, buffer.byteLength - i);
                                    
                                    const testMpegLength = offsetView.getUint32(16);
                                    const testAudioInitLength = offsetView.getUint32(20);
                                    const testVideoInitLength = offsetView.getUint32(24);
                                    const testAudioDataLength = offsetView.getUint32(28);
                                    const testVideoDataLength = offsetView.getUint32(32);
                                    
                                    const testExpectedSize = 36 + testMpegLength + testAudioInitLength + 
                                                           testVideoInitLength + testAudioDataLength + testVideoDataLength;
                                    
                                    // If all sizes look reasonable, we may have found a valid header
                                    if (testExpectedSize < MAX_REASONABLE_SIZE && 
                                        testExpectedSize > 36 &&
                                        testMpegLength < MAX_REASONABLE_SIZE && 
                                        testAudioInitLength < MAX_REASONABLE_SIZE &&
                                        testVideoInitLength < MAX_REASONABLE_SIZE &&
                                        testAudioDataLength < MAX_REASONABLE_SIZE &&
                                        testVideoDataLength < MAX_REASONABLE_SIZE) {
                                        
                                        log(`üîÑ Found potential valid header at offset ${i}`);
                                        buffer = buffer.slice(i);
                                        headerParsed = false;  // Re-parse the header
                                        validHeaderFound = true;
                                        break;
                                    }
                                } catch (e) {
                                    // Skip this position if there's an error
                                }
                            }
                            
                            if (!validHeaderFound) {
                                // If we couldn't find a valid header, discard the buffer and wait for more data
                                log(`‚ùå Could not find valid header, discarding ${buffer.length} bytes`);
                                buffer = new Uint8Array(0);
                                headerParsed = false;
                            }
                            break;
                        }
                    } catch (e) {
                        log(`‚ùå Error parsing header: ${e.message}`);
                        // Discard a byte and try again
                        buffer = buffer.slice(1);
                        headerParsed = false;
                        continue;
                    }
                }
                
                // If we don't have the full packet yet, wait for more data
                if (buffer.length < expectedPacketSize) {
                    if (chunkCounter % 20 === 0) {
                        log(`‚è≥ Waiting for more data: have ${buffer.length} bytes, need ${expectedPacketSize} bytes`);
                    }
                    break;
                }
                
                // We have a complete packet! Extract and process it
                const packetData = buffer.slice(0, expectedPacketSize);
                
                try {
                    // Process the complete packet
                    const success = window.packetHandler.processWMPPacket(packetData);
                    
                    if (!success) {
                        log(`‚ö†Ô∏è Failed to process packet of size ${expectedPacketSize}`);
                    } else if (chunkCounter % 20 === 0) {
                        log(`‚úÖ Successfully processed complete packet of size ${expectedPacketSize} bytes`);
                    }
                } catch (e) {
                    log(`‚ùå Error processing packet: ${e.message}`);
                }
                
                // Remove the processed packet from buffer
                buffer = buffer.slice(expectedPacketSize);
                
                // Reset for next packet
                headerParsed = false;
                expectedPacketSize = 0;
            }
            
            // Check if media is ready and player should be initialized
            if (window.packetHandler.init.video && 
                window.packetHandler.init.audio && 
                window.packetHandler.mpdData && 
                !window.player) {
                setupDashPlayer(window.packetHandler.mpdUrl);
            }
        }
    } catch (error) {
        if (!window.disconnectionRequested) {
            log(`‚ùå Error processing stream #${streamId}: ${error.message}`);
        }
    } finally {
        // Clean up
        const index = window.activeReaders.indexOf(reader);
        if (index > -1) {
            window.activeReaders.splice(index, 1);
        }
        
        try {
            reader.releaseLock();
        } catch (e) {
            // Ignore errors during cleanup
        }
    }
}

/**
 * Listen for incoming WebTransport streams
 */
async function listenToIncomingStreams(transport, packetHandler) {
    if (!transport || !packetHandler) {
        log("‚ùå Cannot listen to streams: missing transport or packetHandler");
        return;
    }

    log("üéß Listening for incoming unidirectional streams...");
    const streamReader = transport.incomingUnidirectionalStreams.getReader();

    let streamId = 0;

    try {
        while (!window.disconnectionRequested) {
            const { value: stream, done } = await streamReader.read();

            if (done) {
                log("üì¥ No more incoming streams ‚Äî reader closed");
                break;
            }

            if (!stream || typeof stream.getReader !== 'function') {
                log("‚ö†Ô∏è Received stream that isn't readable ‚Äî skipping");
                continue;
            }

            streamId++;
            window.streamCounter = streamId; // Update global stream counter
            log(`‚úÖ Incoming QUIC stream #${streamId} received`);
            updateUI(); // Update UI to reflect the new stream

            // Process each stream in its own try-catch block to prevent a single stream error
            // from stopping the listener
            processStream(stream, streamId).catch(error => {
                log(`‚ùå Error processing stream #${streamId}: ${error.message}`);
            });
            
            // Check if we're ready to initialize player after getting the first stream
            if (streamId === 1) {
                // Delay check slightly to allow for first packets to be processed
                setTimeout(checkPlayerReadiness, 500);
            }
        }
    } catch (error) {
        log(`‚ùå Error in stream reader: ${error.message}`);
    } finally {
        log(`üì¥ Stream listener exiting`);
        try {
            streamReader.releaseLock();
        } catch (e) {
            // Ignore errors during cleanup
        }
    }
}

/**
 * Helper function to check if we're ready to initialize player
 */
function checkPlayerReadiness() {
  // Check if player already exists
  if (window.player) {
    log(`üé¨ Player already exists, skipping initialization check`);
    return;
  }
  
  // Check if we have enough fragments and init segments
  const hasVideoInit = window.packetHandler && window.packetHandler.init.video;
  const hasAudioInit = window.packetHandler && window.packetHandler.init.audio;
  const hasMpd = window.packetHandler && window.packetHandler.mpdData;
  
  if (hasVideoInit && hasAudioInit && hasMpd) {
    log(`‚úÖ Init segments and MPD loaded, ready to initialize player`);
    setupDashPlayer(window.packetHandler.mpdUrl);
  } else {
    log(`‚è≥ Waiting for init segments and MPD before initializing player: Video=${hasVideoInit}, Audio=${hasAudioInit}, MPD=${hasMpd}`);
    // Check again in 500ms
    setTimeout(checkPlayerReadiness, 500);
  }
}

/**
 * Properly validate and handle MP4 fragments for MediaSource Extensions
 */

/**
 * Correctly parse and validate MP4 fragment structure
 * @param {Uint8Array} data - Fragment data to parse
 * @returns {Object} Box structure and validation results
 */
 function parseMP4Fragment(data) {
    if (!data || data.byteLength === 0) {
        return { 
            valid: false, 
            hasMoof: false, 
            hasMdat: false, 
            boxes: [],
            error: "Empty data" 
        };
    }

    try {
        // Parse all MP4 boxes in the fragment
        let offset = 0;
        const boxes = [];
        let hasMoof = false;
        let hasMdat = false;
        
        // Continue parsing until we reach the end of the data
        while (offset + 8 <= data.byteLength) {
            // Read size (first 4 bytes, big-endian)
            const size = (data[offset] << 24) | 
                        (data[offset + 1] << 16) | 
                        (data[offset + 2] << 8) | 
                        data[offset + 3];
            
            // Sanity check for size
            if (size < 8 || size > data.byteLength - offset) {
                // This might be a corrupt box, but we'll still return what we parsed
                break;
            }
            
            // Read type (4 bytes after size)
            const type = String.fromCharCode(
                data[offset + 4], data[offset + 5], 
                data[offset + 6], data[offset + 7]
            );
            
            // Record box details
            boxes.push({ type, size, offset });
            
            // Track moof and mdat boxes
            if (type === 'moof') hasMoof = true;
            if (type === 'mdat') hasMdat = true;
            
            // Move to next box
            offset += size;
        }
        
        // Check that we have a valid MP4 fragment structure
        const valid = hasMoof && hasMdat;
        
        // For fragmented MP4, the order should be: [styp] ‚Üí [sidx] ‚Üí moof ‚Üí mdat
        let correctOrder = true;
        const moofIndex = boxes.findIndex(b => b.type === 'moof');
        const mdatIndex = boxes.findIndex(b => b.type === 'mdat');
        
        if (moofIndex !== -1 && mdatIndex !== -1) {
            correctOrder = moofIndex < mdatIndex;
        } else {
            correctOrder = false;
        }
        
        return {
            valid: valid && correctOrder,
            hasMoof,
            hasMdat,
            correctOrder,
            boxes,
            boxStructure: boxes.map(b => `${b.type}(${b.size})`).join(' ‚Üí ')
        };
    } catch (error) {
        return { 
            valid: false, 
            hasMoof: false, 
            hasMdat: false, 
            boxes: [],
            error: error.message 
        };
    }
}

/**
 * Fix issues with media fragments before serving them
 * @param {Uint8Array} data - Media fragment data
 * @param {string} mediaType - "video" or "audio"
 * @returns {Uint8Array} Fixed media fragment
 */
function fixMediaFragmentIfNeeded(data, mediaType) {
    // First analyze the fragment
    const parsedFragment = parseMP4Fragment(data);
    
    // Log the fragment structure
    log(`üß™ ${mediaType} fragment structure: ${parsedFragment.boxStructure}`);
    
    // If it's already valid, return as is
    if (parsedFragment.valid) {
        log(`‚úÖ ${mediaType} fragment is valid (moof=${parsedFragment.hasMoof}, mdat=${parsedFragment.hasMdat})`);
        return data;
    }
    
    log(`‚ö†Ô∏è ${mediaType} fragment needs fixing: moof=${parsedFragment.hasMoof}, mdat=${parsedFragment.hasMdat}, correctOrder=${parsedFragment.correctOrder}`);
    
    // If we can't fix it, at least return the original
    return data;
}

/**
 * Enhanced XMLHttpRequest send method to properly validate and fix media segments
 */
function enhanceXHRForMediaSegments() {
    log(`üîß Enhancing XMLHttpRequest for better media segment handling`);
    
    // Only do this once
    if (window.xhrMediaSegmentEnhanced) {
        log(`‚úÖ XMLHttpRequest already enhanced for media segments`);
        return;
    }
    
    // We'll need the original send method
    const origXHRSend = XMLHttpRequest.prototype.send;
    
    // Replace the send method on XMLHttpRequest prototype
    XMLHttpRequest.prototype.send = function(body) {
        // If this is a media segment request, check and fix if needed
        if (this._isMediaSegment && typeof this._trackId !== 'undefined' && typeof this._segmentId !== 'undefined') {
            const trackId = this._trackId;
            const segmentId = this._segmentId;
            const trackType = trackId === 0 ? "video" : "audio";
            
            // Try to get segment from packetHandler
            let segmentData = null;
            
            if (window.packetHandler && window.packetHandler.buffer[trackType][segmentId]) {
                segmentData = window.packetHandler.buffer[trackType][segmentId];
                log(`üîé Found segment: track=${trackId}, segment=${segmentId} (${segmentData.byteLength} bytes)`);
                
                // Validate the segment data
                const parsedData = parseMP4Fragment(segmentData);
                log(`üß™ ${trackType} segment #${segmentId} structure: ${parsedData.boxStructure}`);
                
                if (parsedData.valid) {
                    log(`‚úÖ ${trackType} segment #${segmentId} has valid structure`);
                } else {
                    log(`‚ö†Ô∏è ${trackType} segment #${segmentId} has invalid structure: moof=${parsedData.hasMoof}, mdat=${parsedData.hasMdat}`);
                    
                    // Now we can try to fix it if needed (not implemented but would go here)
                }
                
                // Serve the media segment with proper validation
                setTimeout(() => {
                    this.responseType = 'arraybuffer';
                    
                    // Make sure we're serving an ArrayBuffer, not a TypedArray
                    let buffer;
                    if (segmentData instanceof Uint8Array) {
                        buffer = segmentData.buffer.slice(
                            segmentData.byteOffset, 
                            segmentData.byteOffset + segmentData.byteLength
                        );
                    } else {
                        buffer = segmentData;
                    }
                    
                    // Set the response
                    Object.defineProperty(this, 'response', { get: () => buffer });
                    Object.defineProperty(this, 'status', { get: () => 200 });
                    Object.defineProperty(this, 'statusText', { get: () => 'OK' });
                    Object.defineProperty(this, 'readyState', { get: () => 4 });
                    
                    // Log the box structure for debugging
                    const firstBytes = new Uint8Array(buffer.slice(0, Math.min(32, buffer.byteLength)));
                    log(`üîç Media segment first bytes: ${Array.from(firstBytes).map(b => b.toString(16).padStart(2, '0')).join(' ')}`);
                    
                    // Dispatch events
                    this.dispatchEvent(new Event('readystatechange'));
                    this.dispatchEvent(new Event('load'));
                    this.dispatchEvent(new Event('loadend'));
                    
                    log(`‚úÖ Media segment served: track=${trackId}, segment=${segmentId}`);
                }, 10);
                
                return;
            } else {
                log(`‚ö†Ô∏è No segment found for track=${trackId}, segment=${segmentId}`);
            }
        }
        
        // For all non-media segments, use original
        origXHRSend.call(this, body);
    };
    
    window.xhrMediaSegmentEnhanced = true;
    log(`‚úÖ XMLHttpRequest enhanced for media segments`);
}

/**
 * Debug function to validate all media fragments in buffer
 */
function validateAllMediaFragments() {
    log(`üîç Validating all media fragments in buffer`);
    
    if (!window.packetHandler) {
        log(`‚ùå No packet handler available`);
        return;
    }
    
    // Loop through video and audio buffers
    ["video", "audio"].forEach(trackType => {
        const buffer = window.packetHandler.buffer[trackType];
        const fragmentIds = Object.keys(buffer).sort((a, b) => parseInt(a) - parseInt(b));
        
        log(`üîç Validating ${fragmentIds.length} ${trackType} fragments`);
        
        let validCount = 0;
        let invalidCount = 0;
        
        fragmentIds.forEach(id => {
            const data = buffer[id];
            
            // Use our new parser to validate the fragment
            const parsedData = parseMP4Fragment(data);
            
            if (parsedData.valid) {
                validCount++;
                
                // Log some samples
                if (parseInt(id) % 10 === 0 || fragmentIds.length < 10) {
                    log(`‚úÖ ${trackType} #${id} is valid: ${parsedData.boxStructure}`);
                }
            } else {
                invalidCount++;
                log(`‚ùå ${trackType} #${id} is INVALID: ${parsedData.boxStructure}`);
                
                // Log the first 32 bytes to help diagnose
                const firstBytes = Array.from(data.slice(0, 32)).map(b => b.toString(16).padStart(2, '0')).join(' ');
                log(`   First 32 bytes: ${firstBytes}`);
            }
        });
        
        log(`üìä ${trackType}: ${validCount} valid fragments, ${invalidCount} invalid fragments`);
    });
}

/**
 * Fix all media source and segment issues to enable playback
 */
function fixMediaSourceAndSegments() {
    log(`üõ†Ô∏è Fixing all media sources and segments for playback`);
    
    // First enhance the XHR for proper media handling
    enhanceXHRForMediaSegments();
    
    // Validate and fix all media fragments in the buffer
    validateAllMediaFragments();
    
    // Try to restart the player with clean sources
    if (window.player) {
        log(`üîÑ Restarting player with optimized settings`);
        
        // Ensure we have a video element
        const videoElement = document.getElementById('videoElement');
        if (!videoElement) {
            log(`‚ùå No video element found!`);
            return;
        }
        
        try {
            // Pause any current playback
            videoElement.pause();
            
            // Force reset all source buffers
            setTimeout(() => {
                // Reset player with the MPD URL
                if (window.packetHandler && window.packetHandler.mpdUrl) {
                    log(`üîÑ Resetting player with MPD: ${window.packetHandler.mpdUrl}`);
                    window.player.attachSource(window.packetHandler.mpdUrl);
                    
                    // Add a delay for initialization
                    setTimeout(() => {
                        // Request init segments and first media segments
                        log(`üîÑ Requesting initialization segments and media fragments`);
                        
                        // Try to play
                        setTimeout(() => {
                            log(`‚ñ∂Ô∏è Attempting to start playback`);
                            videoElement.play()
                                .then(() => log(`‚úÖ Playback started!`))
                                .catch(e => log(`‚ùå Playback failed: ${e.message}`));
                        }, 1000);
                    }, 1000);
                } else {
                    log(`‚ùå No MPD URL available!`);
                }
            }, 500);
        } catch (error) {
            log(`‚ùå Error restarting player: ${error.message}`);
        }
    } else {
        log(`‚ùå No player available!`);
    }
}

function startStatusUpdates() {
    // Clear any existing interval
    if (statusInterval) {
        clearInterval(statusInterval);
    }
    
    statusInterval = setInterval(() => {
        // Skip if disconnected
        if (disconnectionRequested || !transport) {
            clearInterval(statusInterval);
            statusInterval = null;
            return;
        }
        
        // Log buffer status periodically
        if (packetHandler) {
            const stats = packetHandler.getStats();
            log(`üìä Status: ${stats.packetsReceived} packets, ${stats.fragmentsAvailable} fragments (Audio:${stats.audioFragments}, Video:${stats.videoFragments}), Streams:${streamCounter}`);
        }
        
        // Update the UI
        updateUI();
        
    }, 5000); // Update every 5 seconds
    
    // Ensure the UI is updated immediately as well
    updateUI();
}

function disconnectWebTransport() {
    log("‚èπÔ∏è Disconnect requested");
    disconnectionRequested = true;
    window.disconnectionRequested = true;
    
    // Clean up resources
    if (statusInterval) {
        clearInterval(statusInterval);
        statusInterval = null;
        window.statusInterval = null;
    }

    const bufferLoggingIntervals = window.bufferLoggingIntervals || [];
    bufferLoggingIntervals.forEach(interval => clearInterval(interval));
    window.bufferLoggingIntervals = [];
    
    // Cancel all active readers
    activeReaders.forEach(reader => {
        try { reader.cancel().catch(() => {}); } catch (e) {}
    });
    activeReaders = [];
    window.activeReaders = [];
    
    // Close transport connection
    if (transport) {
        transport.close();
        transport = null;
        window.transport = null;
    }
    
    // Clean up packet handler and player
    if (packetHandler) {
        packetHandler.disconnect();
        packetHandler = null;
        window.packetHandler = null;
    }
    
    if (player) {
        try {
            player.reset();
        } catch (e) {}
        player = null;
        window.player = null;
    }
    
    // Reset all counters
    playerState = 'idle';
    window.playerState = 'idle';
    streamCounter = 0;
    window.streamCounter = 0;
    
    // Update UI to reflect disconnect
    updateUI();
    
    // Reset counters in UI directly (in case updateUI doesn't handle it)
    const packetCounter = document.getElementById('packetCounter');
    if (packetCounter) {
        packetCounter.textContent = '0';
        packetCounter.className = 'status-badge';
    }
    
    const streamCounter = document.getElementById('streamCounter');
    if (streamCounter) {
        streamCounter.textContent = '0';
        streamCounter.className = 'status-badge';
    }
}

// Handle connection closed by server
function handleConnectionClosed() {
    if (disconnectionRequested) return; // Don't log if disconnect was requested
    
    log("‚ùå WebTransport connection closed by server");
    
    // Clean up
    disconnectWebTransport();
    
    // Update UI
    const connStatus = document.getElementById('connectionStatus');
    connStatus.textContent = 'Disconnected (by server)';
    connStatus.className = 'status-badge status-disconnected';
}

/**
 * Setup event handlers on page load
 */
 document.addEventListener('DOMContentLoaded', function() {
    log(`üîç Setting up event handlers for WebTransport DASH Player`);
    
    // Initialize global variables if not already done
    window.transport = null;
    window.packetHandler = null;
    window.statusInterval = null;
    window.player = null;
    window.playerState = 'idle';
    window.disconnectionRequested = false;
    window.activeReaders = [];
    window.xhrInterceptionEnabled = false;
    window.streamCounter = 0;
    window.bufferLoggingIntervals = [];
    
    // Check browser support
    if ('WebTransport' in window) {
        log("‚úÖ WebTransport is supported in this browser");
        log(`üîç Browser details: ${navigator.userAgent}`);
    } else {
        log("‚ùå WebTransport is NOT supported in this browser");
        log(`üîç Browser details: ${navigator.userAgent}`);
        const connectButton = document.getElementById('connectButton');
        if (connectButton) {
            connectButton.disabled = true;
            connectButton.title = "WebTransport is not supported in this browser";
        }
        alert("WebTransport is not supported in this browser. Please use Chrome 87+ or Edge 87+.");
        return;
    }
    
    // Add a debug button to the controls
    const controlsDiv = document.querySelector('.controls');
    if (controlsDiv) {
        const debugBtn = document.createElement('button');
        debugBtn.id = 'debugButton';
        debugBtn.className = 'btn';
        debugBtn.textContent = 'Debug Media';
        debugBtn.onclick = debugMediaState;
        controlsDiv.appendChild(debugBtn);
        
        log(`‚úÖ Debug button added to controls`);
    }

    // Connect button handler
    const connectButton = document.getElementById('connectButton');
    if (connectButton) {
        connectButton.addEventListener('click', () => {
            log(`üîç Connect button clicked`);
            
            const urlInput = document.getElementById('wtUrl');
            if (!urlInput) {
                log(`‚ùå URL input field not found`);
                alert("URL input field not found!");
                return;
            }
            
            const url = urlInput.value;
            
            log(`üîç Connection URL: ${url}`);
            
            // Validate URL
            try {
                new URL(url);
                log(`‚úÖ URL validation successful`);
            } catch (e) {
                log(`‚ùå Invalid URL: ${url} - ${e.message}`);
                alert(`Invalid URL: ${e.message}`);
                return;
            }
            
            // Check if URL uses https (required for WebTransport in browsers)
            if (!url.startsWith('https://')) {
                log(`‚ö†Ô∏è Warning: URL does not use HTTPS. WebTransport requires HTTPS in browsers.`);
                alert("WebTransport requires HTTPS URLs. Please use an HTTPS URL.");
                return;
            }
            
            // Disable button while connecting
            connectButton.disabled = true;
            
            log(`üîç Setting up WebTransport connection`);
            
            setupWebTransport(url).then(() => {
                log(`‚úÖ Connection setup completed successfully`);
                connectButton.disabled = true;
                const disconnectButton = document.getElementById('disconnectButton');
                if (disconnectButton) {
                    disconnectButton.disabled = false;
                }
            }).catch(error => {
                log(`‚ùå Connection setup failed: ${error.message}`);
                connectButton.disabled = false;
                
                // Show alert with error details
                alert(`Connection failed: ${error.message}\n\nPlease check the URL and ensure your browser supports WebTransport.`);
            });
        });
    }

    // Play button handler
    const playButton = document.getElementById('playButton');
    if (playButton) {
        playButton.addEventListener('click', () => {
            log(`üîç Play button clicked`);
            
            try {
                if (window.player) {
                    log(`üîç Player exists, checking if ready`);

                    fixPlaybackIssues();
                    fixMediaSourceAndSegments();
                    
                    if (window.player.isReady()) {
                        log('‚ñ∂Ô∏è Player is ready, starting playback');
                        window.player.play();
                        window.playerState = 'playing';
                        
                        // Setup buffer logging
                        const intervalId = setInterval(() => {
                            if (window.playerState === 'playing') {
                                try {
                                    const videoBuffer = window.player.getBufferLength("video") || 0;
                                    const audioBuffer = window.player.getBufferLength("audio") || 0;
                                    log(`üìä Buffer levels: Video=${videoBuffer.toFixed(2)}s, Audio=${audioBuffer.toFixed(2)}s`);
                                } catch (e) {
                                    log(`‚ö†Ô∏è Error logging buffer levels: ${e.message}`);
                                }
                            } else {
                                clearInterval(intervalId);
                            }
                        }, 10000); // Log every 10 seconds
                        
                        if (!window.bufferLoggingIntervals) {
                            window.bufferLoggingIntervals = [];
                        }
                        window.bufferLoggingIntervals.push(intervalId);
                    } else {
                        log('‚ö†Ô∏è Player exists but not ready yet, waiting...');
                        window.playerState = 'buffering';
                        
                        // Try again in a second
                        setTimeout(() => {
                            try {
                                if (window.player && window.player.isReady()) {
                                    log('‚ñ∂Ô∏è Player now ready, starting playback');
                                    window.player.play();
                                    window.playerState = 'playing';
                                } else {
                                    log('‚ùå Player still not ready after timeout');
                                }
                            } catch (e) {
                                log(`‚ùå Error starting playback after timeout: ${e.message}`);
                            }
                            updateUI();
                        }, 1000);
                    }
                    
                    updateUI();
                } else {
                    log('‚ùå Play button clicked but player not initialized');
                    alert('Player not initialized. Please wait for connection to establish and media to be received.');
                }
            } catch (error) {
                log(`‚ùå Error starting playback: ${error.message}`);
                alert(`Playback error: ${error.message}`);
            }
        });
    }

    // Disconnect button handler
    const disconnectButton = document.getElementById('disconnectButton');
    if (disconnectButton) {
        disconnectButton.addEventListener('click', () => {
            log(`üîç Disconnect button clicked`);
            
            try {
                disconnectWebTransport();
                log(`‚úÖ Disconnection completed successfully`);
            } catch (error) {
                log(`‚ùå Error during disconnection: ${error.message}`);
            }
        });
    }

    // Debug button handler
    const debugButton = document.getElementById('debugButton');
    if (debugButton) {
        debugButton.addEventListener('click', () => {
            log(`üîç Debug button clicked`);
            debugMediaState();
            checkConnectionStatus();
            
            // Add any specific debugging you want here
            if (window.packetHandler) {
                const stats = window.packetHandler.getStats();
                log(`üìä Detailed Stats: ${JSON.stringify(stats)}`);
            }
        });
    }
    
    // Initialize UI
    updateUI();
    log(`‚úÖ UI initialization completed`);
    
    log(`üîç WebTransport DASH Player setup completed`);
});

/**
 * Update the UI based on current state
 */
function updateUI() {
    // Get UI elements
    const connStatus = document.getElementById('connectionStatus');
    const bufferStatus = document.getElementById('bufferStatus');
    const playerStatus = document.getElementById('playerStatus');
    const connectBtn = document.getElementById('connectButton');
    const playBtn = document.getElementById('playButton');
    const disconnectBtn = document.getElementById('disconnectButton');
    const packetCounter = document.getElementById('packetCounter');
    const streamCounter = document.getElementById('streamCounter');
    
    // Update connection status
    if (connStatus) {
        if (window.transport) {
            connStatus.textContent = 'Connected';
            connStatus.className = 'status-badge status-connected';
        } else {
            connStatus.textContent = 'Disconnected';
            connStatus.className = 'status-badge status-disconnected';
        }
    }
    
    // Update button states
    if (connectBtn) {
        connectBtn.disabled = !!window.transport;
    }
    
    if (disconnectBtn) {
        disconnectBtn.disabled = !window.transport;
    }
    
    // Update buffer status
    if (bufferStatus && window.packetHandler) {
        const stats = window.packetHandler.getStats();
        const audioCount = stats.audioFragments || 0;
        const videoCount = stats.videoFragments || 0;
        
        bufferStatus.textContent = `${audioCount + videoCount} (A:${audioCount}, V:${videoCount})`;
        
        if (audioCount + videoCount > 0) {
            bufferStatus.className = 'status-badge status-connected';
        } else {
            bufferStatus.className = 'status-badge';
        }
    } else if (bufferStatus) {
        bufferStatus.textContent = '0 (A:0, V:0)';
        bufferStatus.className = 'status-badge';
    }
    
    // Update player status
    if (playerStatus) {
        const state = window.playerState || 'idle';
        playerStatus.textContent = state.charAt(0).toUpperCase() + state.slice(1);
        
        if (state === 'buffering') {
            playerStatus.className = 'status-badge status-buffering';
        } else if (state === 'playing') {
            playerStatus.className = 'status-badge status-connected';
        } else if (state === 'error') {
            playerStatus.className = 'status-badge status-disconnected';
        } else {
            playerStatus.className = 'status-badge';
        }
    }
    
    // Update packet counter
    if (packetCounter && window.packetHandler) {
        const stats = window.packetHandler.getStats();
        packetCounter.textContent = stats.packetsReceived || 0;
        if (stats.packetsReceived > 0) {
            packetCounter.className = 'status-badge status-connected';
        } else {
            packetCounter.className = 'status-badge';
        }
    } else if (packetCounter) {
        packetCounter.textContent = '0';
        packetCounter.className = 'status-badge';
    }
    
    // Update stream counter
    if (streamCounter) {
        streamCounter.textContent = window.streamCounter || 0;
        if (window.streamCounter > 0) {
            streamCounter.className = 'status-badge status-connected';
        } else {
            streamCounter.className = 'status-badge';
        }
    }
    
    // Update play button
    if (playBtn) {
        // Enable play button only if player exists and has init segments and media
        let canPlay = false;
        
        if (window.player && window.packetHandler) {
            const stats = window.packetHandler.getStats();
            const hasMedia = stats.videoFragments > 0 && stats.audioFragments > 0;
            const isPlaying = window.playerState === 'playing' || window.playerState === 'buffering';
            
            canPlay = hasMedia && !isPlaying;
        }
        
        playBtn.disabled = !canPlay;
    }
}

/**
 * Simple logging function that outputs to both console and UI
 */
function log(message) {
    const logEl = document.getElementById('logcatbox');
    if (!logEl) {
        console.log(message);
        return;
    }
    
    const time = new Date().toISOString().split('T')[1].split('.')[0];
    const formattedMessage = `[${time}] ${message}`;
    
    logEl.value += formattedMessage + '\n';
    logEl.scrollTop = logEl.scrollHeight;
    console.log(message);
}

/**
 * Setup DASH.js player with enhanced debugging and configuration
 */
 function setupDashPlayer(mpdUrl = '/vivoh.mpd') {
    if (window.player) {
        log(`üìù Player already exists, skipping creation`);
        return window.player;
    }

    try {
        log(`üé¨ Creating DASH.js player (URL: ${mpdUrl})`);
        
        // Ensure video element exists
        let videoElement = document.getElementById('videoElement');
        if (!videoElement) {
            log(`üé• Creating <video id="videoElement">`);
            videoElement = document.createElement('video');
            videoElement.id = 'videoElement';
            videoElement.className = 'centeredVideo';
            videoElement.controls = true;
            videoElement.autoplay = false;
            videoElement.muted = true; // Required for autoplay policies
            videoElement.playsinline = true;
            
            const container = document.querySelector('.video-container');
            if (container) {
                container.innerHTML = '';
                container.appendChild(videoElement);
            } else {
                document.body.appendChild(videoElement);
            }
        }
        
        // Create player with optimized settings
        window.player = dashjs.MediaPlayer().create();
        
        // Enable debug logging
        window.player.updateSettings({
            'debug': {
                'logLevel': dashjs.Debug.LOG_LEVEL_DEBUG
            }
        });
        
        // Apply streaming settings with more permissive buffer configuration
        window.player.updateSettings({
            'streaming': {
                'buffer': {
                    'fastSwitchEnabled': true,
                    'bufferTimeDefault': 10,          // Lower buffer requirements
                    'bufferTimeAtTopQuality': 15,     // Lower buffer requirements
                    'bufferPruningInterval': 5,       // More frequent pruning
                    'stableBufferTime': 10,          // Maintain reasonable buffer
                    'abandonLoadTimeout': 10000       // Longer timeout for segment loading
                },
                'gaps': {
                    'jumpGaps': true,
                    'jumpLargeGaps': true,
                    'smallGapLimit': 1.8,
                    'threshold': 0.3
                },
                'delay': {
                    'liveDelay': 2,
                    'useSuggestedPresentationDelay': true,
                    'lowLatencyEnabled': false
                },
                'liveCatchup': {
                    'enabled': false,              // Disable catchup for VOD content
                    'playbackRate': {
                        'min': 0.8,
                        'max': 1.2
                    }
                },
                'abr': {
                    'useDefaultABRRules': true,
                    'autoSwitchBitrate': {
                        'audio': true,
                        'video': true
                    },
                    'initialBitrate': {
                        'audio': -1,
                        'video': -1
                    }
                },
                'cmcd': {
                    'enabled': false
                }
            }
        });
        
        // Add event handlers with more detailed logging
        window.player.on(dashjs.MediaPlayer.events.ERROR, (e) => {
            let errorDetail = '';
            if (e.error) {
                errorDetail = e.error.message || '';
                if (e.error.data) {
                    errorDetail += ` (${JSON.stringify(e.error.data)})`;
                }
            }
            log(`‚ùå Player error: ${errorDetail || 'Unknown error'}`);
            
            window.playerState = 'error';
            updateUI();
        });
        
        window.player.on(dashjs.MediaPlayer.events.PLAYBACK_STARTED, () => {
            log(`‚ñ∂Ô∏è Playback started successfully`);
            window.playerState = 'playing';
            updateUI();
        });
        
        window.player.on(dashjs.MediaPlayer.events.PLAYBACK_PAUSED, () => {
            log(`‚è∏Ô∏è Playback paused`);
            window.playerState = 'paused';
            updateUI();
        });
        
        window.player.on(dashjs.MediaPlayer.events.PLAYBACK_WAITING, () => {
            log(`‚è≥ Playback waiting (buffering)`);
            window.playerState = 'buffering';
            updateUI();
        });
        
        // Add segment loading event handlers
        window.player.on(dashjs.MediaPlayer.events.FRAGMENT_LOADING_STARTED, (e) => {
            if (e.request) {
                log(`üîÑ Fragment loading started: type=${e.request.mediaType}, time=${e.request.startTime}, url=${e.request.url}`);
            }
        });
        
        window.player.on(dashjs.MediaPlayer.events.FRAGMENT_LOADING_COMPLETED, (e) => {
            if (e.request && e.request.mediaType) {
                log(`‚úÖ Fragment loaded: type=${e.request.mediaType}, time=${e.request.startTime}, bytes=${e.request.bytesLoaded || 'unknown'}`);
            }
        });
        
        window.player.on(dashjs.MediaPlayer.events.FRAGMENT_LOADING_ABANDONED, (e) => {
            if (e.request) {
                log(`‚ö†Ô∏è Fragment loading abandoned: type=${e.request.mediaType}, time=${e.request.startTime}`);
            }
        });
        
        // Add initialization events
        window.player.on(dashjs.MediaPlayer.events.MANIFEST_LOADED, () => {
            log(`üìÑ Manifest loaded successfully`);
        });
        
        window.player.on(dashjs.MediaPlayer.events.STREAM_INITIALIZED, () => {
            log(`üåä Stream initialized`);
        });
        
        window.player.on(dashjs.MediaPlayer.events.BUFFER_LEVEL_UPDATED, (e) => {
            if (e.mediaType === 'video' && window.playerState === 'buffering') {
                log(`üìä Buffer level (${e.mediaType}): ${e.bufferLevel.toFixed(2)}s`);
            }
        });
        
        // Add media source events
        window.player.on('sourcebufferAppended', (e) => {
            if (e.buffer && e.mediaType) {
                log(`‚ûï Source buffer appended: type=${e.mediaType}, size=${e.buffer.byteLength || 'unknown'}`);
            }
        });
        
        // Track video element state changes
        videoElement.addEventListener('loadedmetadata', () => {
            log(`üé• Video loadedmetadata event - readyState: ${videoElement.readyState}`);
        });
        
        videoElement.addEventListener('canplay', () => {
            log(`üé• Video canplay event - readyState: ${videoElement.readyState}`);
        });
        
        videoElement.addEventListener('playing', () => {
            log(`üé• Video playing event - readyState: ${videoElement.readyState}`);
        });
        
        videoElement.addEventListener('waiting', () => {
            log(`üé• Video waiting event - readyState: ${videoElement.readyState}`);
        });
        
        videoElement.addEventListener('error', (e) => {
            const error = videoElement.error || {};
            log(`üé• Video error event: code=${error.code}, message=${error.message || 'No details'}`);
        });
        
        // Initialize player with manual attachment to video element
        // This gives us more control over the initialization process
        window.player.initialize(videoElement, mpdUrl, false); // Autoplay=false
        
        // Force a re-trigger of initialization
        setTimeout(() => {
            if (window.player && window.playerState !== 'playing') {
                // Reload the manifest to ensure we have latest data
                log(`üîÑ Refreshing manifest and stream setup`);
                window.player.attachSource(mpdUrl);
            }
        }, 2000);
        
        // Additional debugging - periodically log buffer state
        const bufferCheckInterval = setInterval(() => {
            if (!window.player) {
                clearInterval(bufferCheckInterval);
                return;
            }
            
            try {
                const videoBuffer = window.player.getBufferLength("video") || 0;
                const audioBuffer = window.player.getBufferLength("audio") || 0;
                log(`üìä Buffer state: Video=${videoBuffer.toFixed(2)}s, Audio=${audioBuffer.toFixed(2)}s`);
                
                // If we have good buffer but video isn't playing, try to force start
                if (videoBuffer > 5 && audioBuffer > 5 && window.playerState !== 'playing') {
                    log(`üîÑ We have buffer but video isn't playing - attempting to force start`);
                    const videoElement = document.getElementById('videoElement');
                    if (videoElement) {
                        videoElement.currentTime = 0;
                        try {
                            // Try to force a play operation
                            videoElement.play()
                                .then(() => log(`‚úÖ Forced play succeeded!`))
                                .catch(e => log(`‚ùå Forced play failed: ${e.message || 'Unknown error'}`));
                        } catch (e) {
                            log(`‚ùå Error attempting forced play: ${e.message || 'Unknown error'}`);
                        }
                    }
                }
            } catch (e) {
                log(`‚ö†Ô∏è Error checking buffer: ${e.message || 'Unknown error'}`);
            }
        }, 5000);
        
        // Store interval for cleanup
        if (!window.bufferLoggingIntervals) {
            window.bufferLoggingIntervals = [];
        }
        window.bufferLoggingIntervals.push(bufferCheckInterval);
        
        log(`üé¨ DASH.js player initialized with MPD URL: ${mpdUrl}`);
        
        window.playerState = 'ready';
        updateUI();
        
        return window.player;
    } catch (error) {
        log(`‚ùå Error creating DASH.js player: ${error.message}`);
        window.player = null;
        return null;
    }
}

/**
 * Check fragment metadata in detail
 */
function checkFragmentMetadataDetailed() {
    if (!window.packetHandler) {
        log(`‚ùå No packet handler available`);
        return;
    }
    
    ["video", "audio"].forEach(trackType => {
        const buffer = window.packetHandler.buffer[trackType];
        const fragmentIds = Object.keys(buffer).sort((a, b) => parseInt(a) - parseInt(b));
        
        let hasMoofCount = 0;
        let hasMdatCount = 0;
        let segmentSizes = [];
        
        fragmentIds.forEach(id => {
            const data = buffer[id];
            
            // Check for moof and mdat boxes which are essential in a media fragment
            let hasMoof = false;
            let hasMdat = false;
            
            for (let i = 0; i < Math.min(data.length - 8, 200); i += 4) {
                if (i + 8 <= data.length) {
                    const boxTypeAtPos = String.fromCharCode(
                        data[i + 4], data[i + 5], data[i + 6], data[i + 7]
                    );
                    
                    if (boxTypeAtPos === 'moof') {
                        hasMoof = true;
                        hasMoofCount++;
                    }
                    
                    if (boxTypeAtPos === 'mdat') {
                        hasMdat = true;
                        hasMdatCount++;
                    }
                    
                    // Once we found both boxes, no need to continue searching
                    if (hasMoof && hasMdat) break;
                }
            }
            
            segmentSizes.push(data.length);
            
            // Log details for some fragments
            if (parseInt(id) % 10 === 0 || fragmentIds.length < 10) {
                const dataPreview = data.slice(0, Math.min(24, data.length));
                const hexDump = Array.from(dataPreview).map(b => b.toString(16).padStart(2, '0')).join(' ');
                
                log(`  ${trackType} #${id}: ${data.length} bytes, moof=${hasMoof}, mdat=${hasMdat}`);
                log(`  ${trackType} #${id} hex: ${hexDump}`);
            }
        });
        
        // Calculate size statistics
        const avgSize = segmentSizes.length > 0 ? 
            Math.round(segmentSizes.reduce((a, b) => a + b, 0) / segmentSizes.length) : 0;
            
        const minSize = segmentSizes.length > 0 ? Math.min(...segmentSizes) : 0;
        const maxSize = segmentSizes.length > 0 ? Math.max(...segmentSizes) : 0;
        
        log(`üìä ${trackType}: ${fragmentIds.length} fragments, ${hasMoofCount} with moof boxes (${Math.round(hasMoofCount/Math.max(fragmentIds.length, 1)*100)}%), ${hasMdatCount} with mdat boxes (${Math.round(hasMdatCount/Math.max(fragmentIds.length, 1)*100)}%)`);
        log(`üìä ${trackType} size stats: avg=${avgSize} bytes, min=${minSize} bytes, max=${maxSize} bytes`);
        
        if (hasMoofCount < fragmentIds.length) {
            log(`‚ö†Ô∏è WARNING: Some ${trackType} fragments are missing moof boxes! This will prevent playback.`);
        }
        
        if (hasMdatCount < fragmentIds.length) {
            log(`‚ö†Ô∏è WARNING: Some ${trackType} fragments are missing mdat boxes! This will prevent playback.`);
        }
    });
}

/**
 * Add custom DASH.js request interceptor to ensure media segments are properly requested
 */
 function addSegmentRequestListener() {
    // Only add if not already set up
    if (window.dashSegmentRequestListenerAdded) {
        return;
    }
    
    log(`üîÑ Setting up DASH.js segment request listener`);
    
    try {
        // This assumes window.player is your dash.js player instance
        if (!window.player) {
            log(`‚ö†Ô∏è Cannot set up segment request listener - player not initialized`);
            return;
        }
        
        // Add event listener for segment download attempts
        window.player.on('fragmentLoadingStarted', function(e) {
            if (e && e.request) {
                const request = e.request;
                log(`üîç Fragment request started: ${request.url} (type: ${request.mediaType}, time: ${request.startTime})`);
            }
        });
        
        // Add event listener for segment download completions
        window.player.on('fragmentLoadingCompleted', function(e) {
            if (e && e.request) {
                const request = e.request;
                log(`‚úÖ Fragment loaded: ${request.url} (type: ${request.mediaType}, size: ${request.bytesLoaded || 'unknown'})`);
            }
        });
        
        // Add event listener for segment download failures
        window.player.on('fragmentLoadingFailed', function(e) {
            if (e && e.request) {
                log(`‚ùå Fragment loading failed: ${e.request.url} (${e.error ? e.error.message : 'Unknown error'})`);
            }
        });
        
        // Mark as added
        window.dashSegmentRequestListenerAdded = true;
        
        log(`‚úÖ DASH.js segment request listener set up successfully`);
    } catch (error) {
        log(`‚ùå Error setting up segment request listener: ${error.message}`);
    }
}

/**
 * Manually trigger media segment requests if they're not being made automatically
 */
function triggerSegmentRequests() {
    log(`üîÑ Manually triggering initial segment requests`);
    
    try {
        // First ensure our XHR interception is robust
        setupXHRInterception();
        
        // Make sure we have init segments in our buffer
        if (!window.packetHandler || 
            !window.packetHandler.init.video || 
            !window.packetHandler.init.audio) {
            log(`‚ö†Ô∏è Cannot trigger segment requests - missing init segments`);
            return;
        }
        
        // Manually create XMLHttpRequests for init segments
        log(`üîß Manually requesting init segments`);
        
        // Request video init segment
        let videoInitRequest = new XMLHttpRequest();
        videoInitRequest.open('GET', 'init_0.mp4', true);
        videoInitRequest.responseType = 'arraybuffer';
        videoInitRequest.onload = function() {
            if (this.status === 200) {
                log(`‚úÖ Manual video init segment request successful`);
                
                // Now request audio init segment
                let audioInitRequest = new XMLHttpRequest();
                audioInitRequest.open('GET', 'init_1.mp4', true);
                audioInitRequest.responseType = 'arraybuffer';
                audioInitRequest.onload = function() {
                    if (this.status === 200) {
                        log(`‚úÖ Manual audio init segment request successful`);
                        
                        // Now request first media segments
                        requestFirstMediaSegments();
                    } else {
                        log(`‚ùå Manual audio init segment request failed: ${this.status}`);
                    }
                };
                audioInitRequest.onerror = function() {
                    log(`‚ùå Manual audio init segment request error`);
                };
                audioInitRequest.send();
            } else {
                log(`‚ùå Manual video init segment request failed: ${this.status}`);
            }
        };
        videoInitRequest.onerror = function() {
            log(`‚ùå Manual video init segment request error`);
        };
        videoInitRequest.send();
    } catch (error) {
        log(`‚ùå Error triggering segment requests: ${error.message}`);
    }
}

/**
 * Request the first few media segments to bootstrap playback
 */
function requestFirstMediaSegments() {
    log(`üîß Manually requesting first media segments`);
    
    // Helper function to request a single segment
    function requestSegment(trackId, segmentId) {
        return new Promise((resolve, reject) => {
            const url = `chunk_${trackId}_${segmentId}.m4s`;
            let request = new XMLHttpRequest();
            request.open('GET', url, true);
            request.responseType = 'arraybuffer';
            request.onload = function() {
                if (this.status === 200) {
                    log(`‚úÖ Manual segment request successful: ${url}`);
                    resolve(this.response);
                } else {
                    log(`‚ùå Manual segment request failed: ${url} (${this.status})`);
                    reject(new Error(`Status ${this.status}`));
                }
            };
            request.onerror = function() {
                log(`‚ùå Manual segment request error: ${url}`);
                reject(new Error('Network error'));
            };
            request.send();
        });
    }
    
    // Request the first 3 segments for each track
    Promise.all([
        // Video segments (track 0)
        requestSegment(0, 1),
        requestSegment(0, 2),
        requestSegment(0, 3),
        // Audio segments (track 1)
        requestSegment(1, 1),
        requestSegment(1, 2),
        requestSegment(1, 3)
    ]).then(() => {
        log(`‚úÖ Successfully requested initial media segments`);
        
        // Now try to start playback
        if (window.player && document.getElementById('videoElement')) {
            log(`üé¨ Attempting to start playback after manual segment loading`);
            
            // Force media source to recognize we have data
            window.player.seek(0);
            
            setTimeout(() => {
                try {
                    document.getElementById('videoElement').play()
                        .then(() => log(`‚úÖ Playback started successfully`))
                        .catch(e => log(`‚ùå Error starting playback: ${e.message}`));
                } catch (e) {
                    log(`‚ùå Error attempting to play: ${e.message}`);
                }
            }, 1000);
        }
    }).catch(error => {
        log(`‚ùå Error requesting initial segments: ${error.message}`);
    });
}

/**
 * Check if we're missing init segment handling in the MPD
 */
function fixInitSegmentHandling() {
    // First check if the MPD data is available
    if (!window.packetHandler || !window.packetHandler.mpdData) {
        log(`‚ö†Ô∏è Cannot fix MPD - no MPD data available`);
        return;
    }
    
    // Parse the MPD XML
    const parser = new DOMParser();
    const mpd = parser.parseFromString(window.packetHandler.mpdData, 'application/xml');
    
    // Find all Representation elements
    const representations = mpd.querySelectorAll('Representation');
    let modified = false;
    
    // Check if each Representation has an initialization segment
    for (const representation of representations) {
        // Check if it already has a SegmentTemplate with initialization
        const segmentTemplate = representation.querySelector('SegmentTemplate[initialization]');
        if (!segmentTemplate) {
            // Get the id or other identifiers to determine track type
            const id = representation.getAttribute('id') || '';
            const mimeType = representation.getAttribute('mimeType') || '';
            const isVideo = mimeType.includes('video') || id.includes('video');
            const isAudio = mimeType.includes('audio') || id.includes('audio');
            const trackId = isVideo ? 0 : (isAudio ? 1 : null);
            
            if (trackId !== null) {
                // Create a new SegmentTemplate if it doesn't exist
                let segTemplate = representation.querySelector('SegmentTemplate') || 
                                  document.createElement('SegmentTemplate');
                
                // Set the initialization attribute
                segTemplate.setAttribute('initialization', `init_${trackId}.mp4`);
                
                // If SegmentTemplate is new, append it to the Representation
                if (!representation.querySelector('SegmentTemplate')) {
                    representation.appendChild(segTemplate);
                }
                
                modified = true;
                log(`üîß Added initialization segment reference for track ${trackId}`);
            }
        }
    }
    
    if (modified) {
        // Serialize the modified MPD back to string
        const serializer = new XMLSerializer();
        const modifiedMpdString = serializer.serializeToString(mpd);
        
        // Update the MPD data
        window.packetHandler.mpdData = modifiedMpdString;
        
        // Create a new blob URL
        const blob = new Blob([modifiedMpdString], { type: 'application/dash+xml' });
        const oldUrl = window.packetHandler.mpdUrl;
        window.packetHandler.mpdUrl = URL.createObjectURL(blob);
        
        // Register the new MPD blob URL
        if (typeof window.registerMpdBlobUrl === 'function') {
            window.registerMpdBlobUrl(window.packetHandler.mpdUrl, modifiedMpdString);
        }
        
        // Revoke the old blob URL if it's a blob URL
        if (oldUrl && oldUrl.startsWith('blob:')) {
            try {
                URL.revokeObjectURL(oldUrl);
            } catch (e) {
                // Ignore errors during cleanup
            }
        }
        
        log(`‚úÖ Modified MPD to include initialization segment references`);
        return true;
    } else {
        log(`‚ÑπÔ∏è No MPD modifications needed for initialization segments`);
        return false;
    }
}

/**
 * Fix media source configuration to ensure proper playback
 */
function fixMediaSourceConfiguration() {
    log(`üîß Attempting to fix MediaSource configuration`);
    
    try {
        // First ensure we have a player and video element
        if (!window.player || !document.getElementById('videoElement')) {
            log(`‚ö†Ô∏è Cannot fix MediaSource - player or video element not found`);
            return false;
        }
        
        // Reset the DASH.js player with optimized settings
        window.player.updateSettings({
            'streaming': {
                'buffer': {
                    'fastSwitchEnabled': true,
                    'bufferTimeDefault': 8,          // Lower buffer requirements
                    'bufferTimeAtTopQuality': 12,    // Lower buffer requirements
                    'bufferPruningInterval': 4,      // More frequent pruning
                    'stableBufferTime': 8,           // Maintain reasonable buffer
                    'abandonLoadTimeout': 8000       // Longer timeout for segment loading
                },
                'gaps': {
                    'jumpGaps': true,
                    'jumpLargeGaps': true,
                    'smallGapLimit': 1.5,
                    'threshold': 0.3
                },
                'delay': {
                    'liveDelay': 3,
                    'useSuggestedPresentationDelay': false
                },
                'liveCatchup': {
                    'enabled': false,              // Disable catchup for VOD content
                },
                'lastBitrateCachingInfo': {
                    'enabled': false
                },
                'lastMediaSettingsCachingInfo': {
                    'enabled': false
                },
                'cacheLoadThresholds': {
                    'video': 0,
                    'audio': 0
                }
            },
            'debug': {
                'logLevel': dashjs.Debug.LOG_LEVEL_DEBUG
            }
        });
        
        // Modify manifest URL to ensure we get a refresh
        if (window.packetHandler && window.packetHandler.mpdUrl) {
            // Update MPD if needed
            const mpdModified = fixInitSegmentHandling();
            
            if (mpdModified) {
                log(`üîÑ Resetting player with modified MPD: ${window.packetHandler.mpdUrl}`);
                
                // Reset player state
                const videoElement = document.getElementById('videoElement');
                try {
                    // Stop any ongoing playback
                    videoElement.pause();
                    
                    // Reset the player with the updated MPD
                    window.player.attachSource(window.packetHandler.mpdUrl);
                    
                    // Add a delay before attempting to play
                    setTimeout(() => {
                        try {
                            // Force MediaSource to recognize we have data
                            window.player.seek(0);
                            
                            // Trigger segment requests after a short delay
                            setTimeout(() => {
                                triggerSegmentRequests();
                            }, 500);
                        } catch (e) {
                            log(`‚ùå Error during seek/play attempt: ${e.message}`);
                        }
                    }, 1000);
                    
                    return true;
                } catch (e) {
                    log(`‚ùå Error resetting player: ${e.message}`);
                }
            } else {
                // Just trigger segment requests
                triggerSegmentRequests();
            }
        } else {
            log(`‚ö†Ô∏è No MPD URL available to reset player`);
        }
    } catch (error) {
        log(`‚ùå Error fixing MediaSource configuration: ${error.message}`);
    }
    
    return false;
}

/**
 * Main function to fix the video playback issues
 */
function fixPlaybackIssues() {
    log(`üõ†Ô∏è Starting playback issue fixing procedure`);
    
    // Step 1: Add segment request listener
    addSegmentRequestListener();
    
    // Step 2: Check and fix MPD/init segment handling
    fixMediaSourceConfiguration();
    
    // Update UI
    if (typeof updateUI === 'function') {
        updateUI();
    }
    
    log(`üõ†Ô∏è Playback issue fixing procedure completed`);
}

/**
 * Detailed fragment analysis for troubleshooting
 */
function detailedFragmentAnalysis() {
    if (!window.packetHandler) {
        log(`‚ùå No packet handler available for fragment analysis`);
        return;
    }
    
    // Check for properly structured MP4 fragments
    ["video", "audio"].forEach(trackType => {
        const buffer = window.packetHandler.buffer[trackType];
        const fragmentIds = Object.keys(buffer).sort((a, b) => parseInt(a) - parseInt(b));
        
        log(`üîç Analyzing ${fragmentIds.length} ${trackType} fragments...`);
        
        // Use first, middle, and last fragment for detailed inspection
        const sampleIds = [];
        if (fragmentIds.length > 0) sampleIds.push(fragmentIds[0]);
        if (fragmentIds.length > 2) sampleIds.push(fragmentIds[Math.floor(fragmentIds.length / 2)]);
        if (fragmentIds.length > 1) sampleIds.push(fragmentIds[fragmentIds.length - 1]);
        
        sampleIds.forEach(id => {
            const data = buffer[id];
            if (!data || data.length === 0) {
                log(`‚ö†Ô∏è Fragment ${trackType}#${id} is empty!`);
                return;
            }
            
            // Parse all MP4 boxes in the fragment
            let offset = 0;
            const boxes = [];
            
            while (offset + 8 <= data.length) {
                try {
                    // Read size (first 4 bytes, big-endian)
                    const size = (data[offset] << 24) | (data[offset + 1] << 16) | 
                                (data[offset + 2] << 8) | data[offset + 3];
                    
                    // Read type (4 bytes after size)
                    const type = String.fromCharCode(
                        data[offset + 4], data[offset + 5], data[offset + 6], data[offset + 7]
                    );
                    
                    // Record box details
                    boxes.push({ type, size, offset });
                    
                    // Move to next box
                    offset += size;
                    
                    // Sanity check - if size is 0 or too big, we might be parsing garbage
                    if (size === 0 || size > data.length) {
                        log(`‚ö†Ô∏è Invalid box size (${size}) at offset ${offset} in ${trackType}#${id}`);
                        break;
                    }
                } catch (e) {
                    log(`‚ö†Ô∏è Error parsing boxes in ${trackType}#${id}: ${e.message}`);
                    break;
                }
            }
            
            // Log box structure
            const boxStructure = boxes.map(b => `${b.type}(${b.size})`).join(' ‚Üí ');
            log(`üß™ ${trackType}#${id} box structure: ${boxStructure}`);
            
            // Check for valid structure (should have moof followed by mdat)
            const hasMoof = boxes.some(b => b.type === 'moof');
            const hasMdat = boxes.some(b => b.type === 'mdat');
            const correctOrder = boxes.findIndex(b => b.type === 'moof') < boxes.findIndex(b => b.type === 'mdat');
            
            if (!hasMoof || !hasMdat) {
                log(`‚ö†Ô∏è ${trackType}#${id} missing required boxes: moof=${hasMoof}, mdat=${hasMdat}`);
            } else if (!correctOrder) {
                log(`‚ö†Ô∏è ${trackType}#${id} has incorrect box order - moof should come before mdat`);
            } else {
                log(`‚úÖ ${trackType}#${id} has valid MP4 fragment structure`);
            }
        });
    });
}

/**
 * Enhanced debug function to display DASH.js media state
 */
function debugMediaState() {
    log(`üîç DEBUG: Starting detailed media state diagnosis`);
    
    // Check if packetHandler exists
    if (!window.packetHandler) {
        log(`‚ö†Ô∏è No packetHandler available for debugging`);
        log(`üîç Connection status: ${window.transport ? "Connected" : "Not connected"}`);
        log(`üîç Player exists: ${window.player ? "Yes" : "No"}`);
        log(`üîç Player state: ${window.playerState || "Unknown"}`);
        
        // Suggest establishing connection first
        log(`üí° Try connecting to the server first before debugging media`);
        return;
    }
    
    // Check packet and fragment counts
    const stats = window.packetHandler.getStats();
    log(`üìä Media Debug: WMP Packets received: ${stats.packetsReceived}`);
    log(`üìä Fragments: Video=${stats.videoFragments}, Audio=${stats.audioFragments}`);
    log(`üìä Init segments: Video=${stats.videoInitAvailable ? "Yes" : "No"}, Audio=${stats.audioInitAvailable ? "Yes" : "No"}`);
    log(`üìä MPD available: ${stats.mpdAvailable ? "Yes" : "No"}`);
    
    // Check init segments in detail
    checkInitSegmentsDetailed();
    
    // Check fragments in detail
    checkFragmentMetadataDetailed();
    
    // Check player state
    if (window.player) {
        const videoElement = document.getElementById('videoElement');
        if (videoElement) {
            const readyState = videoElement.readyState;
            const readyStateText = ["HAVE_NOTHING", "HAVE_METADATA", "HAVE_CURRENT_DATA", "HAVE_FUTURE_DATA", "HAVE_ENOUGH_DATA"][readyState] || "Unknown";
            
            log(`üìä Player exists, video element readyState=${readyState} (${readyStateText})`);
            log(`üìä Player state: ${window.playerState || "Unknown"}`);
            log(`üìä Video paused: ${videoElement.paused}, Video seeking: ${videoElement.seeking}`);
            log(`üìä Video current time: ${videoElement.currentTime.toFixed(2)}s`);
            log(`üìä Video duration: ${videoElement.duration || 'unknown'}`);
            log(`üìä Video size: ${videoElement.videoWidth}x${videoElement.videoHeight}`);
            
            if (videoElement.error) {
                log(`üìä Video element has error: ${videoElement.error.code} - ${videoElement.error.message || 'No details'}`);
            }
            
            // Check MSE source buffers
            if (videoElement.srcObject) {
                log(`üìä Video has srcObject (likely MediaStream)`);
            } else if (videoElement.src) {
                log(`üìä Video src: ${videoElement.src}`);
            }
            
            // Try to get MediaSource information
            try {
                if (window.player.getSource()) {
                    log(`üìä MediaSource readyState: ${window.player.getSource().readyState}`);
                }
            } catch (e) {
                log(`‚ö†Ô∏è Could not get MediaSource info: ${e.message}`);
            }
            
            try {
                // Try to get DASH.js internal buffer levels
                const videoBufferLevel = window.player.getBufferLength("video") || 0;
                const audioBufferLevel = window.player.getBufferLength("audio") || 0;
                log(`üìä DASH.js buffer levels: Video=${videoBufferLevel.toFixed(2)}s, Audio=${audioBufferLevel.toFixed(2)}s`);
                
                // Check if we have active source buffers
                const sourceBuffers = window.player.getActiveStream()?.getSourceBuffersController()?.getSourceBuffers() || [];
                log(`üìä Active source buffers: ${sourceBuffers.length}`);
                
                // Try to get track info
                const videoTrack = window.player.getCurrentTrackFor("video");
                if (videoTrack) {
                    log(`üìä Video track: codec=${videoTrack.codec}, bitrate=${videoTrack.bitrateValue}, id=${videoTrack.id}`);
                }
                
                const audioTrack = window.player.getCurrentTrackFor("audio");
                if (audioTrack) {
                    log(`üìä Audio track: codec=${audioTrack.codec}, bitrate=${audioTrack.bitrateValue}, id=${audioTrack.id}`);
                }
            } catch (e) {
                log(`‚ö†Ô∏è Error getting DASH.js details: ${e.message}`);
            }
        } else {
            log(`‚ö†Ô∏è Player exists but no video element found!`);
        }
    } else {
        log(`üìä Player does not exist yet`);
    }
    
    // Force detailed diagnosis of media fragments
    log(`üîç Running detailed media fragment diagnosis`);
    detailedFragmentAnalysis();
}

/**
 * Check initialization segments in detail
 */
function checkInitSegmentsDetailed() {
    if (!window.packetHandler) {
        log(`‚ùå No packet handler available`);
        return;
    }
    
    ["video", "audio"].forEach(trackType => {
        const init = window.packetHandler.init[trackType];
        if (!init) {
            log(`‚ùå No init segment for ${trackType}`);
            return;
        }
        
        // Detailed box checking
        let foundFtyp = false;
        let foundMoov = false;
        let foundMvhd = false;
        let foundMvex = false;
        let foundTrex = false;
        
        // Check for required boxes in the init segment
        for (let i = 0; i < Math.min(init.length - 8, 1000); i++) {
            if (i + 8 <= init.length) {
                const boxTypeAtPos = String.fromCharCode(
                    init[i + 4], init[i + 5], init[i + 6], init[i + 7]
                );
                
                if (boxTypeAtPos === 'ftyp') foundFtyp = true;
                if (boxTypeAtPos === 'moov') foundMoov = true;
                if (boxTypeAtPos === 'mvhd') foundMvhd = true;
                if (boxTypeAtPos === 'mvex') foundMvex = true;
                if (boxTypeAtPos === 'trex') foundTrex = true;
            }
        }
        
        // Log the first 32 bytes to help debug format issues
        const initPreview = init.slice(0, Math.min(32, init.length));
        const hexDump = Array.from(initPreview).map(b => b.toString(16).padStart(2, '0')).join(' ');
        
        log(`üß™ ${trackType} init segment: ${init.length} bytes`);
        log(`üß™ ${trackType} init segment hex: ${hexDump}`);
        log(`üß™ ${trackType} init segment boxes: ftyp=${foundFtyp}, moov=${foundMoov}, mvhd=${foundMvhd}, mvex=${foundMvex}, trex=${foundTrex}`);
        
        if (!foundMvex) {
            log(`‚ö†Ô∏è WARNING: ${trackType} init segment missing mvex box, DASH playback may fail!`);
        }
        
        if (!foundFtyp || !foundMoov) {
            log(`‚ö†Ô∏è WARNING: ${trackType} init segment missing required boxes (ftyp=${foundFtyp}, moov=${foundMoov})!`);
        }
    });
}
    </script>
</body>
</html>