<!DOCTYPE html>
<html>
<head>
    <meta content="text/html; charset=utf-8" http-equiv="Content-Type">
    <link rel="icon" href="data:;base64,=">
    <title>Vivoh WebTransport DASH Player</title>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, "Helvetica Neue", Arial, sans-serif;
            margin: 0;
            padding: 20px;
            background: #f5f5f5;
        }
        .mainContainer {
            max-width: 1200px;
            margin: 0 auto;
            background: white;
            padding: 20px;
            border-radius: 8px;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
            text-align: center;
        }
        .url-input {
            margin-bottom: 20px;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 10px;
        }
        .video-container {
            margin: 20px 0;
            background: #000;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }
        .video-logo {
            position: absolute;
            top: 10px;
            left: 10px;
            width: 100px;
            opacity: 0.8;
        }
        .centeredVideo {
            width: 100%;
            margin: 0 auto;
            display: block;
        }
        .logcatBox {
            width: 100%;
            padding: 10px;
            border: 1px solid #ddd;
            border-radius: 4px;
            font-family: monospace;
            background: #f8f9fa;
            height: 200px;
            overflow-y: auto;
            text-align: left;
            margin-top: 20px;
        }
        .controls {
            margin: 20px 0;
        }
        .btn {
            background-color: #1e88e5;
            color: white;
            border: none;
            padding: 10px 20px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 0 10px;
            transition: background-color 0.3s;
        }
        .btn:hover {
            background-color: #1565c0;
        }
        .btn:disabled {
            background-color: #cccccc;
            cursor: not-allowed;
        }
        input[type="text"] {
            padding: 10px;
            border-radius: 4px;
            border: 1px solid #ddd;
            width: 80%;
            font-size: 16px;
        }
        label {
            font-weight: bold;
            white-space: nowrap;
        }
        .status-container {
            display: flex;
            justify-content: center;
            gap: 20px;
            margin: 10px 0;
        }
        .status-indicator {
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .status-label {
            font-weight: bold;
        }
        .status-badge {
            background-color: #f0f0f0;
            padding: 5px 10px;
            border-radius: 12px;
            font-size: 14px;
        }
        .status-connected {
            background-color: #4caf50;
            color: white;
        }
        .status-disconnected {
            background-color: #f44336;
            color: white;
        }
        .status-buffering {
            background-color: #ff9800;
            color: white;
        }
    </style>
</head>
<body>
    <div class="mainContainer">
        <img src="vivoh.png" class="video-logo" alt="Video Logo">
        <div class="url-input">
            <label for="wtUrl">WebTransport URL:</label>
            <input id="wtUrl" type="text" value="https://va01.wtmpeg.com/live" style="width: 70%; padding: 10px;">
        </div>
        <div class="video-container">
            <video id="videoElement" class="centeredVideo" controls playsinline>
                Your browser is too old which doesn't support HTML5 video.
            </video>
        </div>
        <div class="status-container">
            <div class="status-indicator">
                <span class="status-label">Connection:</span>
                <span id="connectionStatus" class="status-badge status-disconnected">Disconnected</span>
            </div>
            <div class="status-indicator">
                <span class="status-label">DASH Fragments:</span>
                <span id="bufferStatus" class="status-badge">0 fragments</span>
            </div>
            <div class="status-indicator">
                <span class="status-label">Player:</span>
                <span id="playerStatus" class="status-badge">Idle</span>
            </div>
            <div class="status-indicator">
                <span class="status-label">QUIC Streams:</span>
                <span id="streamCounter" class="status-badge">0</span>
            </div>
            <div class="status-indicator">
                <span class="status-label">Media Packets:</span>
                <span id="packetCounter" class="status-badge">0</span>
            </div>
        </div>
        <div class="controls">
            <button id="connectButton" class="btn">Connect</button>
            <button id="playButton" class="btn" disabled>Play</button>
            <button id="disconnectButton" class="btn" disabled>Disconnect</button>
        </div>
        <textarea id="logcatbox" class="logcatBox" rows="10" readonly></textarea>
    </div>

    <script src="dash.js"></script>
    <script>
// At the top of your script, modify the global variable declarations:

// Global variables
let transport;
let packetHandler;
let statusInterval;
let player;
let playerState = 'idle';
let disconnectionRequested = false;
let activeReaders = [];
let xhrInterceptionEnabled = false;
let streamCounter = 0;
let bufferLoggingIntervals = [];

// Also add them to window for global access
window.transport = transport;
window.packetHandler = packetHandler;
window.statusInterval = statusInterval;
window.player = player;
window.playerState = playerState;
window.disconnectionRequested = disconnectionRequested;
window.activeReaders = activeReaders;
window.xhrInterceptionEnabled = xhrInterceptionEnabled;
window.streamCounter = streamCounter;
window.bufferLoggingIntervals = bufferLoggingIntervals;

// Constants from server implementation
const PUBLISHER_ROLE_HEADER = new TextEncoder().encode("DOQ-PUB-ROLE-V1");
const PLAYER_ROLE_HEADER = new TextEncoder().encode("DOQ-PLAYER-ROLE-V1");

// Logging function
function log(message) {
    const logEl = document.getElementById('logcatbox');
    const time = new Date().toISOString().split('T')[1].split('.')[0];
    logEl.value += `[${time}] ${message}\n`;
    logEl.scrollTop = logEl.scrollHeight;
    console.log(message);
}



/**
 * WebTransportMediaPacketHandler
 * 
 * Processes media packets received over WebTransport and manages
 * media fragments for DASH playback.
 */
 class WebTransportMediaPacketHandler {
    /**
     * Create a new WebTransportMediaPacketHandler instance
     */
    constructor() {
        // Media buffers by track type
        this.buffer = {
            video: {}, // Map of packetId -> fragment data
            audio: {}  // Map of packetId -> fragment data
        };
        
        // Initialization segments
        this.init = {
            video: null,
            audio: null
        };
        
        // MPD content
        this.mpdData = null;
        this.mpdUrl = '/vivoh.mpd';
        
        // Track-specific buffers with additional metadata
        this.trackBuffers = {
            0: {  // Video track
                fragments: [],
                lastSequence: -1
            },
            1: {  // Audio track
                fragments: [],
                lastSequence: -1
            }
        };
        
        // Statistics and state
        this.bytesReceived = 0;
        this.fragmentsReceived = 0;
        this.wmpPacketsReceived = 0;
        this.lastProcessedPacketId = -1;
        this.isDisconnected = false;
        
        // Event callback
        this.onMpdReady = null;
    }
    
    /**
     * Process a WebTransport Media Packet from the server
     * 
     * @param {Uint8Array|ArrayBuffer} data - The packet data
     * @returns {boolean} - Whether processing was successful
     */
    processWMPPacket(data) {
        try {
            // Convert data to Uint8Array if needed
            const dataArray = this._ensureUint8Array(data);
            
            // Validate minimum packet size (header + 5 length fields)
            if (dataArray.length < 36) {
                log(`⚠️ Packet too small: ${dataArray.length} bytes (minimum 36 required)`);
                return false;
            }
            
            // Parse the header and get fields
            const {
                packetId,
                timestamp,
                duration,
                fields
            } = this._extractPacketHeader(dataArray);
            
            // Check for duplicate packets
            if (packetId === this.lastProcessedPacketId) {
                log(`🔄 Duplicate packet ID: ${packetId}, ignoring`);
                return true;
            }
            
            // Update tracking stats
            this.lastProcessedPacketId = packetId;
            this.wmpPacketsReceived++;
            
            // Extract MPD data from the packet if not already set
            if (!this.mpdData && fields.mpd.byteLength > 0) {
                this._processMpdData(fields.mpd);
            }
            
            // Extract initialization segments from the packet if not already set
            if (!this.init.audio && fields.audioInit.byteLength > 0) {
                this.init.audio = fields.audioInit;
                log(`✅ Extracted audio init segment from packet #${packetId} (${fields.audioInit.byteLength} bytes)`);
            }
            
            if (!this.init.video && fields.videoInit.byteLength > 0) {
                this.init.video = fields.videoInit;
                log(`✅ Extracted video init segment from packet #${packetId} (${fields.videoInit.byteLength} bytes)`);
            }
            
            // Process the media fragments
            if (fields.audioData.byteLength > 0) {
                this._processMediaFragment(1, packetId, fields.audioData, false);
            }
            
            if (fields.videoData.byteLength > 0) {
                this._processMediaFragment(0, packetId, fields.videoData, true);
            }
            
            // Log periodic stats
            if (this.wmpPacketsReceived % 10 === 0) {
                const tsSeconds = Number(timestamp) / 1000000; // Convert microseconds to seconds
                log(`📈 Packet stats: Received=${this.wmpPacketsReceived}, ` +
                    `TS=${tsSeconds.toFixed(3)}s, Duration=${duration}ms, ` +
                    `Buffer size: V=${Object.keys(this.buffer.video).length}, ` +
                    `A=${Object.keys(this.buffer.audio).length}`);
            }
            
            // Update stats
            this.fragmentsReceived += 2; // Audio and video
            this.bytesReceived += dataArray.byteLength;
            
            // Check if we have enough data to start playback
            this._checkPlaybackReadiness();
            
            return true;
        } catch (error) {
            log(`❌ Error processing packet: ${error.message}`);
            return false;
        }
    }
    
    /**
     * Convert incoming data to Uint8Array
     * 
     * @param {Uint8Array|ArrayBuffer|object} data - The input data
     * @returns {Uint8Array} - Normalized data as Uint8Array
     * @private
     */
    _ensureUint8Array(data) {
        if (data instanceof ArrayBuffer) {
            return new Uint8Array(data);
        } else if (data instanceof Uint8Array) {
            return data;
        } else if (data && typeof data === 'object' && 'buffer' in data) {
            // Handle Node.js Buffer or similar buffer-view objects
            return new Uint8Array(data.buffer, data.byteOffset || 0, data.byteLength);
        } else {
            throw new Error(`Invalid data type for packet: ${typeof data}`);
        }
    }
    
    /**
     * Extract header fields and media data from a packet
     * 
     * @param {Uint8Array} dataArray - The packet data
     * @returns {object} - Extracted header fields and media data
     * @private
     */
    _extractPacketHeader(dataArray) {
        const view = new DataView(dataArray.buffer, dataArray.byteOffset, dataArray.byteLength);
        
        // Extract header fields
        const packetId = view.getUint32(0);
        const timestamp = view.getBigUint64(4);
        const duration = view.getUint32(12);
        
        // Extract field lengths
        const fieldLengths = [
            view.getUint32(16),  // mpd length
            view.getUint32(20),  // audio_init length
            view.getUint32(24),  // video_init length
            view.getUint32(28),  // audio_data length
            view.getUint32(32)   // video_data length
        ];
        
        // Calculate field positions
        let position = 36;  // Start after header and field lengths
        const fields = {
            mpd: new Uint8Array(0),
            audioInit: new Uint8Array(0),
            videoInit: new Uint8Array(0),
            audioData: new Uint8Array(0),
            videoData: new Uint8Array(0)
        };
        
        // Extract each field
        if (position + fieldLengths[0] <= dataArray.length) {
            fields.mpd = dataArray.slice(position, position + fieldLengths[0]);
            position += fieldLengths[0];
        }
        
        if (position + fieldLengths[1] <= dataArray.length) {
            fields.audioInit = dataArray.slice(position, position + fieldLengths[1]);
            position += fieldLengths[1];
        }
        
        if (position + fieldLengths[2] <= dataArray.length) {
            fields.videoInit = dataArray.slice(position, position + fieldLengths[2]);
            position += fieldLengths[2];
        }
        
        if (position + fieldLengths[3] <= dataArray.length) {
            fields.audioData = dataArray.slice(position, position + fieldLengths[3]);
            position += fieldLengths[3];
        }
        
        if (position + fieldLengths[4] <= dataArray.length) {
            fields.videoData = dataArray.slice(position, position + fieldLengths[4]);
        }
        
        return {
            packetId,
            timestamp,
            duration,
            fields
        };
    }
    
    /**
     * Process MPD data from a packet
     * 
     * @param {Uint8Array} data - The MPD data
     * @private
     */
    _processMpdData(data) {
        if (data.byteLength === 0) return;
        
        try {
            // Convert the binary MPD data to a string
            const mpdString = new TextDecoder().decode(data);
            this.mpdData = mpdString;
            
            log(`📄 Extracted MPD data (${data.byteLength} bytes)`);
            
            // Create a Blob URL for the MPD if needed
            if (typeof URL !== 'undefined' && URL.createObjectURL) {
                const blob = new Blob([mpdString], { type: 'application/dash+xml' });
                this.mpdUrl = URL.createObjectURL(blob);
                log(`🔗 Created MPD blob URL: ${this.mpdUrl}`);
                
                // Register the MPD blob URL if the function exists
                if (typeof window.registerMpdBlobUrl === 'function') {
                    window.registerMpdBlobUrl(this.mpdUrl, mpdString);
                }
            }
            
            // Notify that the MPD is ready
            if (typeof this.onMpdReady === 'function') {
                this.onMpdReady(this.mpdUrl);
            }
        } catch (error) {
            log(`❌ Error processing MPD data: ${error.message}`);
        }
    }
    
    /**
     * Process a media fragment
     * 
     * @param {number} trackId - Track ID (0=video, 1=audio)
     * @param {number} packetId - Packet sequence number
     * @param {Uint8Array} mediaData - The media data
     * @param {boolean} isVideo - Whether this is a video fragment
     * @private
     */
    _processMediaFragment(trackId, packetId, mediaData, isVideo) {
        const trackType = isVideo ? "video" : "audio";
        
        // Skip empty fragments
        if (mediaData.byteLength === 0) {
            return;
        }
        
        // Enhanced fragment validation
        if (mediaData.byteLength < 8) {
            log(`⚠️ Fragment too small: ${mediaData.byteLength} bytes (minimum 8 required)`);
            return;
        }
        
        // Log the box type for debugging (first 4 bytes = size, next 4 = type)
        if (mediaData.byteLength >= 8) {
            const boxType = String.fromCharCode(
                mediaData[4], mediaData[5], mediaData[6], mediaData[7]
            );
            
            if (packetId % 10 === 0) {
                log(`🧪 Fragment ${packetId} (${trackType}) starts with box: ${boxType}`);
            }
        }
        
        // Add fragment to buffer with proper indexing
        this.buffer[trackType][packetId] = mediaData;
        
        // Also add to track-specific buffers for better organization
        if (!this.trackBuffers[trackId]) {
            this.trackBuffers[trackId] = { fragments: [], lastSequence: -1 };
        }
        
        // Add to fragments array with sequence info
        this.trackBuffers[trackId].fragments.push({
            sequence: packetId,
            data: mediaData,
            isKeyframe: isVideo, // For simplicity, treat all video fragments as keyframes
            timestamp: Date.now()
        });
        
        // Register the media segment in the XHR interception map if available
        if (typeof window.registerMediaSegment === 'function') {
            window.registerMediaSegment(trackId, packetId, mediaData);
        }
        
        // Log fragment details for video (less frequently for audio to reduce log spam)
        if (isVideo && packetId % 10 === 0) {
            log(`📦 ${trackType} fragment #${packetId} processed, size=${mediaData.byteLength}B`);
        }
        
        // Keep buffer size reasonable (keep last 30 fragments)
        if (this.trackBuffers[trackId].fragments.length > 30) {
            this.trackBuffers[trackId].fragments.sort((a, b) => a.sequence - b.sequence);
            this.trackBuffers[trackId].fragments = this.trackBuffers[trackId].fragments.slice(-30);
            
            // Also clean up the main buffer
            const oldKeys = Object.keys(this.buffer[trackType])
                .map(Number)
                .sort((a, b) => a - b)
                .slice(0, -30);
                
            for (const key of oldKeys) {
                delete this.buffer[trackType][key];
            }
        }
        
        // Update last sequence
        this.trackBuffers[trackId].lastSequence = Math.max(
            this.trackBuffers[trackId].lastSequence, 
            packetId
        );
    }
    
    /**
     * Check if we have enough data to start playback
     * @private
     */
    _checkPlaybackReadiness() {
        // If player already exists, don't create another one
        if (window.player) {
            return;
        }
        
        // Check if we have initialization segments and MPD
        const hasVideoInit = this.init.video !== null;
        const hasAudioInit = this.init.audio !== null;
        const hasMpd = this.mpdData !== null;
        
        // Check if we have enough fragments
        const videoCount = Object.keys(this.buffer.video).length;
        const audioCount = Object.keys(this.buffer.audio).length;
        
        // Wait until we have enough data to start playback
        if (hasVideoInit && hasAudioInit && hasMpd && videoCount >= 3 && audioCount >= 3) {
            log(`✅ Media ready: MPD=${hasMpd}, V=${videoCount}/${hasVideoInit}, A=${audioCount}/${hasAudioInit}`);
            
            // Notify that we're ready to initialize the player
            if (typeof this.onMpdReady === 'function') {
                this.onMpdReady(this.mpdUrl);
            }
        }
    }
    
    /**
     * Get a media fragment by track and segment ID
     * 
     * @param {number} trackId - Track ID (0=video, 1=audio)
     * @param {number} segmentId - Segment sequence number
     * @returns {Uint8Array|null} - The fragment data or null if not found
     */
    getFragment(trackId, segmentId) {
        const trackType = trackId === 0 ? "video" : "audio";
        
        // For initialization segments
        if (segmentId === 0 || segmentId === -1) {
            return this.init[trackType];
        }
        
        // For media segments
        const buffer = this.buffer[trackType];
        
        // Try to find exact segment ID
        if (buffer[segmentId]) {
            return buffer[segmentId];
        }
        
        // If not found, get closest segment ID
        const keys = Object.keys(buffer).map(Number).sort((a, b) => a - b);
        
        // Find closest segment (prefer newer segments)
        if (keys.length > 0) {
            // Sort by closeness to the requested segment ID
            keys.sort((a, b) => Math.abs(a - segmentId) - Math.abs(b - segmentId));
            const closestId = keys[0];
            
            log(`⚠️ Segment #${segmentId} not found, using closest #${closestId}`);
            return buffer[closestId];
        }
        
        return null;
    }
    
    /**
     * Get statistics about buffer state
     * 
     * @returns {object} - Statistics
     */
    getStats() {
        const videoFragCount = Object.keys(this.buffer.video).length;
        const audioFragCount = Object.keys(this.buffer.audio).length;
        
        return {
            bytesReceived: this.bytesReceived,
            audioFragments: audioFragCount,
            videoFragments: videoFragCount,
            fragmentsReceived: this.fragmentsReceived,
            fragmentsAvailable: videoFragCount + audioFragCount,
            packetsReceived: this.wmpPacketsReceived,
            videoInitAvailable: this.init.video !== null,
            audioInitAvailable: this.init.audio !== null,
            mpdAvailable: this.mpdData !== null
        };
    }
    
    /**
     * Clean up resources before disconnection
     */
    disconnect() {
        this.isDisconnected = true;
        log(`🧹 Cleaning up packet handler resources`);
        
        // Clear buffers
        this.buffer.video = {};
        this.buffer.audio = {};
        
        // Clear track-specific buffers
        Object.keys(this.trackBuffers).forEach(trackId => {
            this.trackBuffers[trackId].fragments = [];
        });
        
        // Clear MPD data
        if (this.mpdUrl && this.mpdUrl.startsWith('blob:')) {
            try {
                URL.revokeObjectURL(this.mpdUrl);
            } catch (e) {
                // Ignore errors during cleanup
            }
        }
        
        this.mpdData = null;
        this.mpdUrl = '/vivoh.mpd';
        
        // Clear initialization segments
        this.init.video = null;
        this.init.audio = null;
    }
}

function isInitSegment(data) {
    // Must have enough data for basic check
    if (!data || data.byteLength < 12) return false;
    
    try {
        // Check for ftyp box which is typically at the start of an init segment
        const possibleFtyp = new TextDecoder().decode(data.slice(4, 8));
        if (possibleFtyp === 'ftyp') return true;
        
        // Check for moov box which is essential in an init segment
        // We'll scan the first 100 bytes for it as it might not be right at the start
        for (let i = 0; i < Math.min(data.byteLength - 8, 100); i += 4) {
            const possibleBox = new TextDecoder().decode(data.slice(i + 4, i + 8));
            if (possibleBox === 'moov') return true;
        }
    } catch (e) {
        // If any parsing error occurs, assume it's not an init segment
        log(`⚠️ Error checking for init segment: ${e.message}`);
    }
    
    return false;
}

/**
 * Log detailed media state information for debugging
 */
 function debugMediaState() {
    log(`🔍 DEBUG: Starting media state diagnosis`);
    
    // Check if packetHandler exists
    if (!window.packetHandler) {
        log(`⚠️ No packetHandler available for debugging`);
        log(`🔍 Connection status: ${window.transport ? "Connected" : "Not connected"}`);
        log(`🔍 Player exists: ${window.player ? "Yes" : "No"}`);
        log(`🔍 Player state: ${window.playerState || "Unknown"}`);
        
        // Suggest establishing connection first
        log(`💡 Try connecting to the server first before debugging media`);
        return;
    }
    
    // Check packet and fragment counts
    const stats = window.packetHandler.getStats();
    log(`📊 Media Debug: WMP Packets received: ${stats.packetsReceived}`);
    log(`📊 Fragments: Video=${stats.videoFragments}, Audio=${stats.audioFragments}`);
    log(`📊 Init segments: Video=${stats.videoInitAvailable ? "Yes" : "No"}, Audio=${stats.audioInitAvailable ? "Yes" : "No"}`);
    log(`📊 MPD available: ${stats.mpdAvailable ? "Yes" : "No"}`);
    
    // Check init segments
    checkInitSegments();
    
    // Check fragments
    checkFragmentMetadata();
    
    // Check player state
    if (window.player) {
        const videoElement = document.getElementById('videoElement');
        const readyState = videoElement.readyState;
        const readyStateText = ["HAVE_NOTHING", "HAVE_METADATA", "HAVE_CURRENT_DATA", "HAVE_FUTURE_DATA", "HAVE_ENOUGH_DATA"][readyState] || "Unknown";
        
        log(`📊 Player exists, video element readyState=${readyState} (${readyStateText})`);
        log(`📊 Player state: ${window.playerState || "Unknown"}`);
        log(`📊 Video paused: ${videoElement.paused}, Video seeking: ${videoElement.seeking}`);
        log(`📊 Video current time: ${videoElement.currentTime.toFixed(2)}s`);
        
        try {
            // Try to get DASH.js internal buffer levels
            const videoBufferLevel = window.player.getBufferLength("video") || 0;
            const audioBufferLevel = window.player.getBufferLength("audio") || 0;
            log(`📊 DASH.js buffer levels: Video=${videoBufferLevel.toFixed(2)}s, Audio=${audioBufferLevel.toFixed(2)}s`);
        } catch (e) {
            log(`⚠️ Could not get DASH.js buffer levels: ${e.message}`);
        }
    } else {
        log(`📊 Player does not exist yet`);
    }
}

/**
 * Check initialization segments
 */
function checkInitSegments() {
    if (!window.packetHandler) {
        log(`❌ No packet handler available`);
        return;
    }
    
    ["video", "audio"].forEach(trackType => {
        const init = window.packetHandler.init[trackType];
        if (!init) {
            log(`❌ No init segment for ${trackType}`);
            return;
        }
        
        // Check for mvex box (required for DASH)
        let foundMvex = false;
        let foundMoov = false;
        
        for (let i = 0; i < Math.min(init.length - 8, 2000); i++) {
            if (i + 8 <= init.length) {
                const boxTypeAtPos = String.fromCharCode(
                    init[i + 4], init[i + 5], init[i + 6], init[i + 7]
                );
                
                if (boxTypeAtPos === 'mvex') {
                    foundMvex = true;
                }
                
                if (boxTypeAtPos === 'moov') {
                    foundMoov = true;
                }
            }
        }
        
        log(`🧪 ${trackType} init segment: ${init.length} bytes, moov=${foundMoov}, mvex=${foundMvex}`);
        
        if (!foundMvex) {
            log(`⚠️ WARNING: ${trackType} init segment missing mvex box, DASH playback may fail!`);
        }
    });
}

/**
 * Check fragment metadata
 */
function checkFragmentMetadata() {
    if (!window.packetHandler) {
        log(`❌ No packet handler available`);
        return;
    }
    
    ["video", "audio"].forEach(trackType => {
        const buffer = window.packetHandler.buffer[trackType];
        const fragmentIds = Object.keys(buffer).sort((a, b) => parseInt(a) - parseInt(b));
        
        let hasMoofCount = 0;
        
        fragmentIds.forEach(id => {
            const data = buffer[id];
            
            // Check for moof box which is essential in a media fragment
            let hasMoof = false;
            for (let i = 0; i < Math.min(data.length - 8, 100); i += 4) {
                if (i + 8 <= data.length) {
                    const boxTypeAtPos = String.fromCharCode(
                        data[i + 4], data[i + 5], data[i + 6], data[i + 7]
                    );
                    
                    if (boxTypeAtPos === 'moof') {
                        hasMoof = true;
                        hasMoofCount++;
                        break;
                    }
                }
            }
            
            // Log details for some fragments
            if (parseInt(id) % 10 === 0) {
                log(`  ${trackType} #${id}: ${data.length} bytes, moof=${hasMoof}`);
            }
        });
        
        log(`📊 ${trackType}: ${fragmentIds.length} fragments, ${hasMoofCount} with moof boxes (${Math.round(hasMoofCount/Math.max(fragmentIds.length, 1)*100)}%)`);
    });
}

/**
 * Check the WebTransport connection status
 */
function checkConnectionStatus() {
    if (!window.transport) {
        log(`⚠️ No active WebTransport connection`);
        return false;
    }
    
    try {
        // For WebTransport, check if we have any active readers
        if (window.activeReaders && window.activeReaders.length > 0) {
            log(`✅ WebTransport connection has ${window.activeReaders.length} active readers`);
            return true;
        }
        
        // Try to create a datagram writer as a test
        const writer = window.transport.datagrams?.writable?.getWriter();
        if (writer) {
            writer.releaseLock();
            log(`✅ WebTransport connection appears active (datagram test passed)`);
            return true;
        }
        
        log(`⚠️ WebTransport connection exists but may be inactive`);
        return false;
    } catch (e) {
        log(`❌ WebTransport connection test failed: ${e.message}`);
        return false;
    }
}

const initCache = {
  "init_0.mp4": null,
  "init_1.mp4": null,
};

function respond404() {
    return new Response("Segment not found", { status: 404 });
}

function respond(data) {
    return new Response(data, {
        status: 200,
        headers: {
            "Content-Type": "video/mp4",
        },
    });
}

function handleSegmentRequest(url) {
  // Use packetHandler's init segments instead of undefined variables
  if (url.endsWith("init_0.mp4")) {
    if (initCache["init_0.mp4"]) return respond(initCache["init_0.mp4"]);
    if (window.packetHandler && window.packetHandler.init.video) {
      initCache["init_0.mp4"] = window.packetHandler.init.video;
      return respond(window.packetHandler.init.video);
    }
    return respond404();
  }
  
  if (url.endsWith("init_1.mp4")) {
    if (initCache["init_1.mp4"]) return respond(initCache["init_1.mp4"]);
    if (window.packetHandler && window.packetHandler.init.audio) {
      initCache["init_1.mp4"] = window.packetHandler.init.audio;
      return respond(window.packetHandler.init.audio);
    }
    return respond404();
  }

  // Improved media segment handling
  if (url.match(/chunk_\d+_\d+\.m4s/)) {
    const match = url.match(/chunk_(\d+)_(\d+)\.m4s/);
    if (match && window.packetHandler) {
      const trackId = parseInt(match[1]);
      const segmentId = parseInt(match[2]);
      
      const trackType = trackId === 0 ? 'video' : 'audio';
      const buffer = window.packetHandler.buffer[trackType];
      
      if (buffer && buffer[segmentId]) {
        log(`🎬 Serving exact segment: track=${trackId}, id=${segmentId}`);
        return respond(buffer[segmentId]);
      }
      
      // Try to find closest segment
      const keys = Object.keys(buffer || {}).map(Number).sort((a, b) => a - b);
      const next = keys.find(k => k > segmentId);

      if (next && Math.abs(next - segmentId) < 100) {
        log(`🎬 Segment #${segmentId} not found, using next #${next}`);
        return respond(buffer[next]);
      }

      const latest = keys[keys.length - 1];
      if (latest && latest > segmentId) {
        log(`🎬 Using latest segment #${latest} instead of #${segmentId}`);
        return respond(buffer[latest]);
      }
    }
    
    log(`⚠️ Segment not found for URL: ${url}`);
    return respond404();
  }

  return respond404();
}

function extractSegmentId(url) {
    const match = url.match(/chunk_\d+_(\d+)\.m4s/);
    return match ? parseInt(match[1], 10) : NaN;
}

/**
 * Set up XHR interception to serve media content from our buffer
 */
 function setupXHRInterception() {
  if (window.xhrInterceptionEnabled) return;
  
  log("🔄 Setting up XMLHttpRequest interception");
  window.xhrInterceptionEnabled = true;
  
  const originalXHROpen = XMLHttpRequest.prototype.open;
  const originalXHRSend = XMLHttpRequest.prototype.send;
  
  // Create a map to store blob URLs and their corresponding data
  const blobUrlMap = new Map();
  
  // Add method to register MPD blob URLs
  window.registerMpdBlobUrl = (url, mpdData) => {
    blobUrlMap.set(url, mpdData);
    log(`📄 Registered MPD blob URL: ${url}`);
  };
  
  // Add method to register media segments
  window.registerMediaSegment = (trackId, segmentId, data) => {
    const key = `segment-${trackId}-${segmentId}`;
    blobUrlMap.set(key, data);
  };
  
  // Log all XHR requests to debug
  XMLHttpRequest.prototype.open = function(method, url, async) {
    this._url = url;
    this._method = method;
    
    if (method === 'GET' && typeof url === 'string') {
      log(`🔍 XHR Request: ${method} ${url}`);
    }
    
    // Track request type
    if (typeof url === 'string') {
      // Check if this is a blob URL that we've registered
      if (url.startsWith('blob:') && blobUrlMap.has(url)) {
        this._isMpdBlobUrl = true;
        log(`📄 Recognized registered MPD blob URL: ${url}`);
      }
      // Standard MPD requests
      else if (url.includes('.mpd')) {
        this._isMPDRequest = true;
        log(`📄 MPD request detected: ${url}`);
      } 
      // Init segment requests
      else if (url.includes('init_')) {
        this._isInitSegment = true;
        const match = url.match(/init_(\d+)\.mp4/);
        if (match) {
          this._trackId = parseInt(match[1]);
          log(`🔑 Init segment request for track ${this._trackId}`);
        }
      } 
      // Media segment requests
      else if (url.match(/chunk_\d+_\d+\.m4s/) || url.match(/chunk-\d+-\d+\.m4s/)) {
        this._isMediaSegment = true;
        let match = url.match(/chunk_(\d+)_(\d+)\.m4s/);
        if (!match) {
          match = url.match(/chunk-(\d+)-(\d+)\.m4s/);
        }
        
        if (match) {
          this._trackId = parseInt(match[1]);
          this._segmentId = parseInt(match[2]);
          log(`🎬 Media segment request: track=${this._trackId}, segment=${this._segmentId}`);
        }
      }
      // External requests - don't try to intercept these
      else if (url.includes('time.akamai.com') || url.includes('/api/')) {
        this._isExternalRequest = true;
      }
    }
    
    originalXHROpen.call(this, method, url, async !== false);
  };
  
  XMLHttpRequest.prototype.send = function(body) {
    // External requests - always pass through
    if (this._isExternalRequest) {
      originalXHRSend.call(this, body);
      return;
    }
    
    // MPD Blob URL Request - serve from our map
    if (this._isMpdBlobUrl && blobUrlMap.has(this._url)) {
      log(`📄 Serving registered MPD blob from map (${this._url})`);
      
      const mpdData = blobUrlMap.get(this._url);
      
      setTimeout(() => {
        this.responseType = 'text';
        Object.defineProperty(this, 'response', { get: () => mpdData });
        Object.defineProperty(this, 'responseText', { get: () => mpdData });
        Object.defineProperty(this, 'status', { get: () => 200 });
        Object.defineProperty(this, 'statusText', { get: () => 'OK' });
        Object.defineProperty(this, 'readyState', { get: () => 4 });
        
        this.dispatchEvent(new Event('readystatechange'));
        this.dispatchEvent(new Event('load'));
        this.dispatchEvent(new Event('loadend'));
        
        log(`✅ Blob MPD served successfully`);
      }, 10);
      
      return;
    }
    
    // Standard MPD Request
    if (this._isMPDRequest && window.packetHandler?.mpdData) {
      log(`📄 Serving MPD from WebTransport packet (${window.packetHandler.mpdData.length} bytes)`);
      
      setTimeout(() => {
        this.responseType = 'text';
        Object.defineProperty(this, 'response', { get: () => window.packetHandler.mpdData });
        Object.defineProperty(this, 'responseText', { get: () => window.packetHandler.mpdData });
        Object.defineProperty(this, 'status', { get: () => 200 });
        Object.defineProperty(this, 'statusText', { get: () => 'OK' });
        Object.defineProperty(this, 'readyState', { get: () => 4 });
        
        this.dispatchEvent(new Event('readystatechange'));
        this.dispatchEvent(new Event('load'));
        this.dispatchEvent(new Event('loadend'));
        
        log(`✅ MPD served successfully`);
      }, 10);
      
      return;
    }
    
    // Init Segment Request
    if (this._isInitSegment && typeof this._trackId !== 'undefined') {
      const trackId = this._trackId;
      const trackType = trackId === 0 ? "video" : "audio";
      
      // Check if we have an init segment for this track
      if (window.packetHandler?.init[trackType]) {
        const initData = window.packetHandler.init[trackType];
        log(`🔑 Serving ${trackType} init segment (${initData.byteLength} bytes)`);
        
        setTimeout(() => {
          this.responseType = 'arraybuffer';
          
          // Make sure we're serving an ArrayBuffer, not a TypedArray
          let buffer;
          if (initData instanceof Uint8Array) {
            buffer = initData.buffer.slice(
              initData.byteOffset, 
              initData.byteOffset + initData.byteLength
            );
          } else {
            buffer = initData;
          }
          
          Object.defineProperty(this, 'response', { get: () => buffer });
          Object.defineProperty(this, 'status', { get: () => 200 });
          Object.defineProperty(this, 'statusText', { get: () => 'OK' });
          Object.defineProperty(this, 'readyState', { get: () => 4 });
          
          this.dispatchEvent(new Event('readystatechange'));
          this.dispatchEvent(new Event('load'));
          this.dispatchEvent(new Event('loadend'));
          
          log(`✅ Init segment served: track=${trackId}`);
        }, 10);
        
        return;
      } else {
        log(`⚠️ No init segment available for track ${trackId}`);
      }
    }
    
    // Media Segment Request
    if (this._isMediaSegment && typeof this._trackId !== 'undefined' && typeof this._segmentId !== 'undefined') {
      const trackId = this._trackId;
      const segmentId = this._segmentId;
      
      // Try to get segment from packetHandler
      const segmentData = findMediaSegment(trackId, segmentId);
      
      if (segmentData) {
        log(`🎬 Serving segment: track=${trackId}, segment=${segmentId} (${segmentData.byteLength} bytes)`);
        
        setTimeout(() => {
          this.responseType = 'arraybuffer';
          
          // Make sure we're serving an ArrayBuffer, not a TypedArray
          let buffer;
          if (segmentData instanceof Uint8Array) {
            buffer = segmentData.buffer.slice(
              segmentData.byteOffset, 
              segmentData.byteOffset + segmentData.byteLength
            );
          } else {
            buffer = segmentData;
          }
          
          Object.defineProperty(this, 'response', { get: () => buffer });
          Object.defineProperty(this, 'status', { get: () => 200 });
          Object.defineProperty(this, 'statusText', { get: () => 'OK' });
          Object.defineProperty(this, 'readyState', { get: () => 4 });
          
          this.dispatchEvent(new Event('readystatechange'));
          this.dispatchEvent(new Event('load'));
          this.dispatchEvent(new Event('loadend'));
          
          log(`✅ Media segment served: track=${trackId}, segment=${segmentId}`);
        }, 10);
        
        return;
      } else {
        log(`⚠️ No media segment available for track=${trackId}, segment=${segmentId}`);
        // Respond with 404 to allow DASH.js to retry
        setTimeout(() => {
          Object.defineProperty(this, 'status', { get: () => 404 });
          Object.defineProperty(this, 'statusText', { get: () => 'Not Found' });
          Object.defineProperty(this, 'readyState', { get: () => 4 });
          
          this.dispatchEvent(new Event('readystatechange'));
          this.dispatchEvent(new Event('load'));
          this.dispatchEvent(new Event('loadend'));
        }, 10);
        
        return;
      }
    }
    
    // Fall back to original XHR behavior for any unhandled requests
    originalXHRSend.call(this, body);
  };
  
  // Helper function to find media segment in buffer
  function findMediaSegment(trackId, segmentId) {
    if (!window.packetHandler) return null;
    
    const trackType = trackId === 0 ? "video" : "audio";
    const buffer = window.packetHandler.buffer[trackType];
    
    if (!buffer || Object.keys(buffer).length === 0) return null;
    
    // Try exact match first
    if (buffer[segmentId]) {
      return buffer[segmentId];
    }
    
    // Get all available segment IDs
    const keys = Object.keys(buffer)
      .map(k => parseInt(k, 10))
      .sort((a, b) => a - b);
    
    if (keys.length === 0) return null;
    
    // Try to find a segment close to the requested one
    const closerSegments = keys.filter(k => Math.abs(k - segmentId) < 10);
    if (closerSegments.length > 0) {
      // Prefer segments that come after the requested one
      const futureSegments = closerSegments.filter(k => k >= segmentId);
      if (futureSegments.length > 0) {
        const closest = futureSegments.sort((a, b) => a - b)[0];
        log(`🔍 Using future segment: ${trackType} #${closest} instead of #${segmentId}`);
        return buffer[closest];
      }
      
      // Otherwise use closest available
      const closest = closerSegments.sort((a, b) => Math.abs(a - segmentId) - Math.abs(b - segmentId))[0];
      log(`🔍 Using nearest segment: ${trackType} #${closest} instead of #${segmentId}`);
      return buffer[closest];
    }
    
    // Fallback to the newest segment
    const latest = keys[keys.length - 1];
    log(`🔍 Using latest segment: ${trackType} #${latest} instead of #${segmentId}`);
    return buffer[latest];
  }
  
  log(`✅ Enhanced XHR interception setup completed`);
  return true;
}

function updateUI() {
    // Get UI elements
    const connStatus = document.getElementById('connectionStatus');
    const bufferStatus = document.getElementById('bufferStatus');
    const playerStatus = document.getElementById('playerStatus');
    const connectBtn = document.getElementById('connectButton');
    const playBtn = document.getElementById('playButton');
    const disconnectBtn = document.getElementById('disconnectButton');
    const packetCounter = document.getElementById('packetCounter');
    const streamCounter = document.getElementById('streamCounter');
    
    // ===== Connection status =====
    if (transport) {
        connStatus.textContent = 'Connected';
        connStatus.className = 'status-badge status-connected';
        connectBtn.disabled = true;
        disconnectBtn.disabled = false;
    } else {
        connStatus.textContent = 'Disconnected';
        connStatus.className = 'status-badge status-disconnected';
        connectBtn.disabled = false;
        disconnectBtn.disabled = true;
    }
    
    // ===== DASH Fragments status =====
    if (window.packetHandler) {
        const stats = window.packetHandler.getStats();
        const audioCount = stats.audioFragments || 0;
        const videoCount = stats.videoFragments || 0;
        
        bufferStatus.textContent = `${audioCount + videoCount} (A:${audioCount}, V:${videoCount})`;
        
        if (audioCount + videoCount > 0) {
            bufferStatus.className = 'status-badge status-connected';
        } else {
            bufferStatus.className = 'status-badge';
        }
        
        // Update media packets counter
        if (packetCounter) {
            packetCounter.textContent = stats.packetsReceived || 0;
            if (stats.packetsReceived > 0) {
                packetCounter.className = 'status-badge status-connected';
            } else {
                packetCounter.className = 'status-badge';
            }
        }
    } else {
        bufferStatus.textContent = '0 (A:0, V:0)';
        bufferStatus.className = 'status-badge';
        
        if (packetCounter) {
            packetCounter.textContent = '0';
            packetCounter.className = 'status-badge';
        }
    }
    
    // ===== Player status =====
    playerStatus.textContent = window.playerState.charAt(0).toUpperCase() + window.playerState.slice(1);
    
    if (window.playerState === 'buffering') {
        playerStatus.className = 'status-badge status-buffering';
    } else if (window.playerState === 'playing') {
        playerStatus.className = 'status-badge status-connected';
    } else if (window.playerState === 'error') {
        playerStatus.className = 'status-badge status-disconnected';
    } else {
        playerStatus.className = 'status-badge';
    }
    
    // ===== QUIC Streams counter =====
    if (streamCounter) {
        streamCounter.textContent = window.streamCounter || 0;
        if (window.streamCounter > 0) {
            streamCounter.className = 'status-badge status-connected';
        } else {
            streamCounter.className = 'status-badge';
        }
    }
    
    // ===== Play button state =====
    if (window.player) {
        // Enable play button if player exists and isn't currently playing
        playBtn.disabled = (window.playerState === 'playing' || window.playerState === 'buffering');
    } else {
        // Disable play button if player doesn't exist
        playBtn.disabled = true;
    }
}

// Enhanced player logging
function logPlayerEvent(event, data) {
  const message = `🎬 Player Event [${event}]: ${JSON.stringify(data || {})}`;
  log(message);
}

// Add more detailed buffer logging
function logBufferState() {
  if (!player) return;
  
  try {
    const videoBuffer = player.getBufferLength('video');
    const audioBuffer = player.getBufferLength('audio');
    const quality = player.getQualityFor('video');
    const bandwidth = player.getBandwidthEstimate();
    
    log(`📊 Buffer: Video=${videoBuffer.toFixed(2)}s, Audio=${audioBuffer.toFixed(2)}s, Quality=${quality}, BW=${(bandwidth/1000).toFixed(0)}kbps`);
  } catch (e) {
    log(`⚠️ Error getting buffer info: ${e.message}`);
  }
}

// Enhanced player debugging
function logPlayerDebugInfo() {
  if (!player) return;
  
  try {
    const videoTrackInfo = player.getCurrentTrackFor('video');
    const audioTrackInfo = player.getCurrentTrackFor('audio');
    
    log(`🔍 Video Track: ${JSON.stringify(videoTrackInfo)}`);
    log(`🔍 Audio Track: ${JSON.stringify(audioTrackInfo)}`);
    
    // Get active stream info
    const activeStream = player.getActiveStream();
    if (activeStream) {
      log(`🔍 Active Stream ID: ${activeStream.getId()}`);
    }
    
    // Get adaptation set info
    const streamInfo = player.getStreamInfo();
    if (streamInfo) {
      log(`🔍 Stream Period ID: ${streamInfo.id}`);
      const videoAdaptation = player.getAdaptationForType(streamInfo.id, 'video');
      const audioAdaptation = player.getAdaptationForType(streamInfo.id, 'audio');
      
      if (videoAdaptation) {
        log(`🔍 Video Adaptation: ${JSON.stringify(videoAdaptation.id)}`);
      }
      
      if (audioAdaptation) {
        log(`🔍 Audio Adaptation: ${JSON.stringify(audioAdaptation.id)}`);
      }
    }
  } catch (e) {
    log(`⚠️ Error getting debug info: ${e.message}`);
  }
}

// Helper to check if data already has MP4 structure
function hasMP4Structure(data) {
  try {
    // Need at least 8 bytes to check box type
    if (data.byteLength < 8) return false;
    
    // Check for common MP4 boxes
    const boxType = new TextDecoder().decode(data.slice(4, 8));
    if (boxType === 'moof' || boxType === 'styp' || boxType === 'sidx') {
      return true;
    }
    
    // Check for secondary boxes
    if (data.byteLength >= 16) {
      const secondBoxOffset = new DataView(data.buffer, data.byteOffset, 4).getUint32(0);
      if (secondBoxOffset < data.byteLength - 8) {
        const secondBoxType = new TextDecoder().decode(data.slice(secondBoxOffset + 4, secondBoxOffset + 8));
        if (secondBoxType === 'mdat' || secondBoxType === 'moof') {
          return true;
        }
      }
    }
    
    return false;
  } catch (e) {
    log(`⚠️ Error checking MP4 structure: ${e.message}`);
    return false;
  }
}

function createSyntheticInitSegment(trackId) {
  const isVideo = trackId === 0;
  
  // Basic structure for a minimal MP4 initialization segment
  const videoInit = new Uint8Array([
    // ftyp box
    0x00, 0x00, 0x00, 0x18, 0x66, 0x74, 0x79, 0x70, 0x69, 0x73, 0x6f, 0x6d, 
    0x00, 0x00, 0x00, 0x01, 0x69, 0x73, 0x6f, 0x6d, 0x61, 0x76, 0x63, 0x31,
    
    // moov box (simplified)
    0x00, 0x00, 0x00, 0x6c, 0x6d, 0x6f, 0x6f, 0x76, 
    
    // mvhd box (simplified)
    0x00, 0x00, 0x00, 0x6c, 0x6d, 0x76, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x00, 0x00,
    
    // trak box (simplified)
    0x00, 0x00, 0x00, 0x5c, 0x74, 0x72, 0x61, 0x6b, 
    
    // tkhd box (simplified)
    0x00, 0x00, 0x00, 0x5c, 0x74, 0x6b, 0x68, 0x64, 0x00, 0x00, 0x00, 0x01,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // mdia box with minimal info (simplified)
    0x00, 0x00, 0x00, 0x20, 0x6d, 0x64, 0x69, 0x61,
    0x00, 0x00, 0x00, 0x20, 0x6d, 0x64, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x55, 0xc4, 0x00, 0x00
  ]);
  
  const audioInit = new Uint8Array([
    // ftyp box
    0x00, 0x00, 0x00, 0x18, 0x66, 0x74, 0x79, 0x70, 0x69, 0x73, 0x6f, 0x6d, 
    0x00, 0x00, 0x00, 0x01, 0x69, 0x73, 0x6f, 0x6d, 0x61, 0x76, 0x63, 0x31,
    
    // moov box (simplified)
    0x00, 0x00, 0x00, 0x6c, 0x6d, 0x6f, 0x6f, 0x76, 
    
    // mvhd box (simplified)
    0x00, 0x00, 0x00, 0x6c, 0x6d, 0x76, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x03, 0xe8, 0x00, 0x00, 0x00, 0x00,
    
    // trak box (simplified)
    0x00, 0x00, 0x00, 0x5c, 0x74, 0x72, 0x61, 0x6b, 
    
    // tkhd box (simplified)
    0x00, 0x00, 0x00, 0x5c, 0x74, 0x6b, 0x68, 0x64, 0x00, 0x00, 0x00, 0x02,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x01, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    
    // mdia box with minimal info (simplified)
    0x00, 0x00, 0x00, 0x20, 0x6d, 0x64, 0x69, 0x61,
    0x00, 0x00, 0x00, 0x20, 0x6d, 0x64, 0x68, 0x64, 0x00, 0x00, 0x00, 0x00,
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xBB, 0x80, 0x00, 0x00
  ]);
  
  // Return the appropriate init segment based on track ID
  log(`🔧 Created synthetic init segment for ${isVideo ? "video" : "audio"} track`);
  return isVideo ? videoInit : audioInit;
}

/**
 * Setup WebTransport connection and handlers
 * 
 * @param {string} url - WebTransport server URL
 * @returns {WebTransportMediaPacketHandler} - The packet handler
 */
 async function setupWebTransport(url) {
  try {
    window.disconnectionRequested = false;
    
    log(`🔍 Setting up WebTransport with URL: ${url}`);
    
    // Clear any existing resources
    if (window.transport) {
      try { 
        window.transport.close(); 
      } catch (e) {
        log(`🔍 Error closing existing transport: ${e.message}`);
      }
      window.transport = null;
    }
    
    // Initialize packet handler
    window.packetHandler = new WebTransportMediaPacketHandler();
    
    // Set MPD ready callback to initialize player
    window.packetHandler.onMpdReady = (mpdUrl) => {
      log(`📄 MPD ready for playback: ${mpdUrl}`);
      setupDashPlayer(mpdUrl);
    };
    
    // Setup XHR interception BEFORE creating WebTransport connection
    setupXHRInterception();
    
    // Connect to WebTransport 
    log(`🔗 Connecting to WebTransport server: ${url}`);
    
    const createStartTime = Date.now();
    window.transport = new WebTransport(url);
    const createEndTime = Date.now();
    
    log(`📡 WebTransport object created in ${createEndTime - createStartTime}ms`);
    
    // Set up connection closed handler
    window.transport.closed.then(() => {
      log(`ℹ️ Connection closed normally`);
      if (!window.disconnectionRequested) {
        handleConnectionClosed();
      }
    }).catch((error) => {
      log(`❌ Connection closed with error: ${error.message}`);
      if (!window.disconnectionRequested) {
        handleConnectionClosed();
      }
    });
    
    // Listen for incoming streams
    listenToIncomingStreams(window.transport, window.packetHandler).catch(err => {
      log(`❌ Error in stream listener: ${err.message}`);
    });
    
    // Start status updates
    startStatusUpdates();
    
    // Update UI
    updateUI();
    
    log(`✅ WebTransport setup completed successfully`);
    
    return window.packetHandler;
  } catch (error) {
    log(`❌ WebTransport error: ${error.message}`);
    updateUI();
    throw error;
  }
}

/**
 * Start periodic status updates
 */
function startStatusUpdates() {
    // Clear any existing interval
    if (window.statusInterval) {
        clearInterval(window.statusInterval);
    }
    
    window.statusInterval = setInterval(() => {
        // Skip if disconnected
        if (window.disconnectionRequested || !window.transport) {
            clearInterval(window.statusInterval);
            window.statusInterval = null;
            return;
        }
        
        // Log buffer status periodically
        if (window.packetHandler) {
            const stats = window.packetHandler.getStats();
            log(`📊 Status: ${stats.packetsReceived} packets, ${stats.fragmentsAvailable} fragments (Audio:${stats.audioFragments}, Video:${stats.videoFragments}), Streams:${window.streamCounter || 0}`);
        }
        
        // Update the UI
        updateUI();
        
    }, 5000); // Update every 5 seconds
    
    // Ensure the UI is updated immediately as well
    updateUI();
}

/**
 * Disconnect WebTransport and clean up resources
 */
function disconnectWebTransport() {
    log("⏹️ Disconnect requested");
    window.disconnectionRequested = true;
    
    // Clean up resources
    if (window.statusInterval) {
        clearInterval(window.statusInterval);
        window.statusInterval = null;
    }
    
    const bufferLoggingIntervals = window.bufferLoggingIntervals || [];
    bufferLoggingIntervals.forEach(interval => clearInterval(interval));
    window.bufferLoggingIntervals = [];
    
    // Cancel all active readers
    const activeReaders = window.activeReaders || [];
    activeReaders.forEach(reader => {
        try { reader.cancel().catch(() => {}); } catch (e) {}
    });
    window.activeReaders = [];
    
    // Close transport connection
    if (window.transport) {
        window.transport.close();
        window.transport = null;
    }
    
    // Clean up packet handler and player
    if (window.packetHandler) {
        window.packetHandler.disconnect();
        window.packetHandler = null;
    }
    
    if (window.player) {
        try {
            window.player.reset();
        } catch (e) {}
        window.player = null;
    }
    
    // Reset all counters
    window.playerState = 'idle';
    window.streamCounter = 0;
    
    // Update UI to reflect disconnect
    updateUI();
    
    // Reset counters in UI directly (in case updateUI doesn't handle it)
    const packetCounter = document.getElementById('packetCounter');
    if (packetCounter) {
        packetCounter.textContent = '0';
        packetCounter.className = 'status-badge';
    }
    
    const streamCounter = document.getElementById('streamCounter');
    if (streamCounter) {
        streamCounter.textContent = '0';
        streamCounter.className = 'status-badge';
    }
    
    const bufferStatus = document.getElementById('bufferStatus');
    if (bufferStatus) {
        bufferStatus.textContent = '0 (A:0, V:0)';
        bufferStatus.className = 'status-badge';
    }
}

/**
 * Handle connection closed by server
 */
function handleConnectionClosed() {
    if (window.disconnectionRequested) return; // Don't log if disconnect was requested
    
    log("❌ WebTransport connection closed by server");
    
    // Clean up
    disconnectWebTransport();
    
    // Update UI
    const connStatus = document.getElementById('connectionStatus');
    if (connStatus) {
        connStatus.textContent = 'Disconnected (by server)';
        connStatus.className = 'status-badge status-disconnected';
    }
}

// Function to preload initialization segments from server
async function preloadInitSegments() {
  try {
    log(`🔄 Preloading initialization segments from server...`);
    
    // Fetch video init segment
    fetch('/init_0.mp4')
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        return response.arrayBuffer();
      })
      .then(buffer => {
        const data = new Uint8Array(buffer);
        log(`✅ Loaded video init segment from server (${data.byteLength} bytes)`);
        
        // Store the init segment in packetHandler
        if (window.packetHandler) {
          window.packetHandler.init.video = data;
        }
      })
      .catch(error => {
        log(`❌ Error loading video init segment: ${error.message}`);
      });
    
    // Fetch audio init segment
    fetch('/init_1.mp4')
      .then(response => {
        if (!response.ok) {
          throw new Error(`HTTP error! Status: ${response.status}`);
        }
        return response.arrayBuffer();
      })
      .then(buffer => {
        const data = new Uint8Array(buffer);
        log(`✅ Loaded audio init segment from server (${data.byteLength} bytes)`);
        
        // Store the init segment in packetHandler
        if (window.packetHandler) {
          window.packetHandler.init.audio = data;
        }
      })
      .catch(error => {
        log(`❌ Error loading audio init segment: ${error.message}`);
      });
  } catch (error) {
    log(`❌ Error in preloadInitSegments: ${error.message}`);
  }
}

// Helper function to check if we're ready to initialize player
function checkPlayerReadiness() {
  // Check if player already exists
  if (window.player) {
    log(`🎬 Player already exists, skipping initialization check`);
    return;
  }
  
  // Check if we have enough fragments and init segments
  const hasVideoInit = window.packetHandler && window.packetHandler.init.video;
  const hasAudioInit = window.packetHandler && window.packetHandler.init.audio;
  
  if (hasVideoInit && hasAudioInit) {
    log(`✅ Init segments loaded, ready to initialize player`);
    setupDashPlayer();
  } else {
    log(`⏳ Waiting for init segments before initializing player`);
    // Check again in 500ms
    setTimeout(checkPlayerReadiness, 500);
  }
}

async function listenToIncomingStreams(transport, packetHandler) {
    if (!transport || !packetHandler) {
        log("❌ Cannot listen to streams: missing transport or packetHandler");
        return;
    }

    log("🎧 Listening for incoming unidirectional streams...");
    const streamReader = transport.incomingUnidirectionalStreams.getReader();

    let streamId = 0;

    try {
        while (!disconnectionRequested) {
            const { value: stream, done } = await streamReader.read();

            if (done) {
                log("📴 No more incoming streams — reader closed");
                break;
            }

            if (!stream || typeof stream.getReader !== 'function') {
                log("⚠️ Received stream that isn't readable — skipping");
                continue;
            }

            streamId++;
            window.streamCounter = streamId; // Update global stream counter
            log(`✅ Incoming QUIC stream #${streamId} received`);
            updateUI(); // Update UI to reflect the new stream

            // Process each stream in its own try-catch block to prevent a single stream error
            // from stopping the listener
            processStream(stream, streamId).catch(error => {
                log(`❌ Error processing stream #${streamId}: ${error.message}`);
            });
            
            // Check if we're ready to initialize player after getting the first stream
            if (streamId === 1) {
                // Delay check slightly to allow for first packets to be processed
                setTimeout(checkPlayerReadiness, 500);
            }
        }
    } catch (error) {
        log(`❌ Error in stream reader: ${error.message}`);
    } finally {
        log(`📴 Stream listener exiting`);
        try {
            streamReader.releaseLock();
        } catch (e) {
            // Ignore errors during cleanup
        }
    }
}

/**
 * Process a WebTransport stream
 * 
 * @param {ReadableStream} stream - The WebTransport stream
 * @param {number} streamId - Stream identifier for logging
 */
 async function processStream(stream, streamId) {
    if (!stream || !window.packetHandler || window.disconnectionRequested) {
        log(`⚠️ Cannot process stream #${streamId}: stream or handler unavailable or disconnection requested`);
        return;
    }
    
    log(`📥 Starting to read from stream #${streamId}`);
    
    let reader;
    try {
        reader = stream.getReader();
        window.activeReaders.push(reader);
    } catch (error) {
        log(`❌ Error creating reader for stream #${streamId}: ${error.message}`);
        return;
    }
    
    try {
        let totalBytes = 0;
        let buffer = new Uint8Array(0);
        let chunkCounter = 0;
        
        while (!window.disconnectionRequested) {
            const { value, done } = await reader.read();
            
            if (done) {
                // Process any remaining data in buffer
                if (buffer.length >= 36) { // Updated minimum size for header + field lengths
                    try {
                        log(`Processing final buffer of ${buffer.length} bytes`);
                        window.packetHandler.processWMPPacket(buffer);
                    } catch (e) {
                        log(`❌ Error processing final buffer: ${e.message}`);
                    }
                }
                
                log(`📴 Stream #${streamId} closed (received ${totalBytes} bytes in ${chunkCounter} chunks)`);
                break;
            }
            
            if (!value || value.byteLength === 0) {
                log(`⚠️ Empty chunk received on stream #${streamId}`);
                continue;
            }
            
            chunkCounter++;
            totalBytes += value.byteLength;
            
            // Log periodically to avoid flooding
            if (chunkCounter === 1 || chunkCounter % 20 === 0) {
                log(`📦 Stream #${streamId} chunk #${chunkCounter}: ${value.byteLength} bytes (total: ${totalBytes})`);
            }
            
            // Try to process the chunk directly if it's large enough
            if (value.byteLength >= 36) { // Updated minimum size for our packet format
                try {
                    const processed = window.packetHandler.processWMPPacket(value);
                    if (processed) {
                        // Successfully processed as standalone chunk
                        continue; // Skip buffer handling
                    }
                } catch (e) {
                    // Failed to process as standalone chunk, will add to buffer
                    log(`⚠️ Error processing chunk directly: ${e.message}`);
                }
            }
            
            // Append to buffer
            const newBuffer = new Uint8Array(buffer.length + value.length);
            newBuffer.set(buffer);
            newBuffer.set(value, buffer.length);
            buffer = newBuffer;
            
            // Try to process buffer if it's large enough
            if (buffer.length >= 36) { // Updated minimum size
                try {
                    const result = window.packetHandler.processWMPPacket(buffer);
                    if (result) {
                        // Buffer successfully processed, clear it
                        buffer = new Uint8Array(0);
                    }
                } catch (e) {
                    // Keep data in buffer, might need more data
                    log(`⚠️ Error processing buffered data: ${e.message}`);
                }
            }
            
            // Check if media is ready and player should be initialized
            if (window.packetHandler.init.video && 
                window.packetHandler.init.audio && 
                window.packetHandler.mpdData && 
                !window.player) {
                setupDashPlayer(window.packetHandler.mpdUrl);
            }
        }
    } catch (error) {
        if (!window.disconnectionRequested) {
            log(`❌ Error processing stream #${streamId}: ${error.message}`);
        }
    } finally {
        // Clean up
        const index = window.activeReaders.indexOf(reader);
        if (index > -1) {
            window.activeReaders.splice(index, 1);
        }
        
        try {
            reader.releaseLock();
        } catch (e) {
            // Ignore errors during cleanup
        }
    }
}

/**
 * Listen for incoming WebTransport streams
 */
async function listenToIncomingStreams(transport, packetHandler) {
    if (!transport || !packetHandler) {
        log("❌ Cannot listen to streams: missing transport or packetHandler");
        return;
    }

    log("🎧 Listening for incoming unidirectional streams...");
    const streamReader = transport.incomingUnidirectionalStreams.getReader();

    let streamId = 0;

    try {
        while (!window.disconnectionRequested) {
            const { value: stream, done } = await streamReader.read();

            if (done) {
                log("📴 No more incoming streams — reader closed");
                break;
            }

            if (!stream || typeof stream.getReader !== 'function') {
                log("⚠️ Received stream that isn't readable — skipping");
                continue;
            }

            streamId++;
            window.streamCounter = streamId; // Update global stream counter
            log(`✅ Incoming QUIC stream #${streamId} received`);
            updateUI(); // Update UI to reflect the new stream

            // Process each stream in its own try-catch block to prevent a single stream error
            // from stopping the listener
            processStream(stream, streamId).catch(error => {
                log(`❌ Error processing stream #${streamId}: ${error.message}`);
            });
            
            // Check if we're ready to initialize player after getting the first stream
            if (streamId === 1) {
                // Delay check slightly to allow for first packets to be processed
                setTimeout(checkPlayerReadiness, 500);
            }
        }
    } catch (error) {
        log(`❌ Error in stream reader: ${error.message}`);
    } finally {
        log(`📴 Stream listener exiting`);
        try {
            streamReader.releaseLock();
        } catch (e) {
            // Ignore errors during cleanup
        }
    }
}

/**
 * Helper function to check if we're ready to initialize player
 */
function checkPlayerReadiness() {
  // Check if player already exists
  if (window.player) {
    log(`🎬 Player already exists, skipping initialization check`);
    return;
  }
  
  // Check if we have enough fragments and init segments
  const hasVideoInit = window.packetHandler && window.packetHandler.init.video;
  const hasAudioInit = window.packetHandler && window.packetHandler.init.audio;
  const hasMpd = window.packetHandler && window.packetHandler.mpdData;
  
  if (hasVideoInit && hasAudioInit && hasMpd) {
    log(`✅ Init segments and MPD loaded, ready to initialize player`);
    setupDashPlayer(window.packetHandler.mpdUrl);
  } else {
    log(`⏳ Waiting for init segments and MPD before initializing player: Video=${hasVideoInit}, Audio=${hasAudioInit}, MPD=${hasMpd}`);
    // Check again in 500ms
    setTimeout(checkPlayerReadiness, 500);
  }
}



function startStatusUpdates() {
    // Clear any existing interval
    if (statusInterval) {
        clearInterval(statusInterval);
    }
    
    statusInterval = setInterval(() => {
        // Skip if disconnected
        if (disconnectionRequested || !transport) {
            clearInterval(statusInterval);
            statusInterval = null;
            return;
        }
        
        // Log buffer status periodically
        if (packetHandler) {
            const stats = packetHandler.getStats();
            log(`📊 Status: ${stats.packetsReceived} packets, ${stats.fragmentsAvailable} fragments (Audio:${stats.audioFragments}, Video:${stats.videoFragments}), Streams:${streamCounter}`);
        }
        
        // Update the UI
        updateUI();
        
    }, 5000); // Update every 5 seconds
    
    // Ensure the UI is updated immediately as well
    updateUI();
}

function disconnectWebTransport() {
    log("⏹️ Disconnect requested");
    disconnectionRequested = true;
    window.disconnectionRequested = true;
    
    // Clean up resources
    if (statusInterval) {
        clearInterval(statusInterval);
        statusInterval = null;
        window.statusInterval = null;
    }

    const bufferLoggingIntervals = window.bufferLoggingIntervals || [];
    bufferLoggingIntervals.forEach(interval => clearInterval(interval));
    window.bufferLoggingIntervals = [];
    
    // Cancel all active readers
    activeReaders.forEach(reader => {
        try { reader.cancel().catch(() => {}); } catch (e) {}
    });
    activeReaders = [];
    window.activeReaders = [];
    
    // Close transport connection
    if (transport) {
        transport.close();
        transport = null;
        window.transport = null;
    }
    
    // Clean up packet handler and player
    if (packetHandler) {
        packetHandler.disconnect();
        packetHandler = null;
        window.packetHandler = null;
    }
    
    if (player) {
        try {
            player.reset();
        } catch (e) {}
        player = null;
        window.player = null;
    }
    
    // Reset all counters
    playerState = 'idle';
    window.playerState = 'idle';
    streamCounter = 0;
    window.streamCounter = 0;
    
    // Update UI to reflect disconnect
    updateUI();
    
    // Reset counters in UI directly (in case updateUI doesn't handle it)
    const packetCounter = document.getElementById('packetCounter');
    if (packetCounter) {
        packetCounter.textContent = '0';
        packetCounter.className = 'status-badge';
    }
    
    const streamCounter = document.getElementById('streamCounter');
    if (streamCounter) {
        streamCounter.textContent = '0';
        streamCounter.className = 'status-badge';
    }
}

// Handle connection closed by server
function handleConnectionClosed() {
    if (disconnectionRequested) return; // Don't log if disconnect was requested
    
    log("❌ WebTransport connection closed by server");
    
    // Clean up
    disconnectWebTransport();
    
    // Update UI
    const connStatus = document.getElementById('connectionStatus');
    connStatus.textContent = 'Disconnected (by server)';
    connStatus.className = 'status-badge status-disconnected';
}

/**
 * Setup event handlers on page load
 */
 document.addEventListener('DOMContentLoaded', function() {
    log(`🔍 Setting up event handlers for WebTransport DASH Player`);
    
    // Initialize global variables if not already done
    window.transport = null;
    window.packetHandler = null;
    window.statusInterval = null;
    window.player = null;
    window.playerState = 'idle';
    window.disconnectionRequested = false;
    window.activeReaders = [];
    window.xhrInterceptionEnabled = false;
    window.streamCounter = 0;
    window.bufferLoggingIntervals = [];
    
    // Check browser support
    if ('WebTransport' in window) {
        log("✅ WebTransport is supported in this browser");
        log(`🔍 Browser details: ${navigator.userAgent}`);
    } else {
        log("❌ WebTransport is NOT supported in this browser");
        log(`🔍 Browser details: ${navigator.userAgent}`);
        const connectButton = document.getElementById('connectButton');
        if (connectButton) {
            connectButton.disabled = true;
            connectButton.title = "WebTransport is not supported in this browser";
        }
        alert("WebTransport is not supported in this browser. Please use Chrome 87+ or Edge 87+.");
        return;
    }
    
    // Add a debug button to the controls
    const controlsDiv = document.querySelector('.controls');
    if (controlsDiv) {
        const debugBtn = document.createElement('button');
        debugBtn.id = 'debugButton';
        debugBtn.className = 'btn';
        debugBtn.textContent = 'Debug Media';
        debugBtn.onclick = debugMediaState;
        controlsDiv.appendChild(debugBtn);
        
        log(`✅ Debug button added to controls`);
    }

    // Connect button handler
    const connectButton = document.getElementById('connectButton');
    if (connectButton) {
        connectButton.addEventListener('click', () => {
            log(`🔍 Connect button clicked`);
            
            const urlInput = document.getElementById('wtUrl');
            if (!urlInput) {
                log(`❌ URL input field not found`);
                alert("URL input field not found!");
                return;
            }
            
            const url = urlInput.value;
            
            log(`🔍 Connection URL: ${url}`);
            
            // Validate URL
            try {
                new URL(url);
                log(`✅ URL validation successful`);
            } catch (e) {
                log(`❌ Invalid URL: ${url} - ${e.message}`);
                alert(`Invalid URL: ${e.message}`);
                return;
            }
            
            // Check if URL uses https (required for WebTransport in browsers)
            if (!url.startsWith('https://')) {
                log(`⚠️ Warning: URL does not use HTTPS. WebTransport requires HTTPS in browsers.`);
                alert("WebTransport requires HTTPS URLs. Please use an HTTPS URL.");
                return;
            }
            
            // Disable button while connecting
            connectButton.disabled = true;
            
            log(`🔍 Setting up WebTransport connection`);
            
            setupWebTransport(url).then(() => {
                log(`✅ Connection setup completed successfully`);
                connectButton.disabled = true;
                const disconnectButton = document.getElementById('disconnectButton');
                if (disconnectButton) {
                    disconnectButton.disabled = false;
                }
            }).catch(error => {
                log(`❌ Connection setup failed: ${error.message}`);
                connectButton.disabled = false;
                
                // Show alert with error details
                alert(`Connection failed: ${error.message}\n\nPlease check the URL and ensure your browser supports WebTransport.`);
            });
        });
    }

    // Play button handler
    const playButton = document.getElementById('playButton');
    if (playButton) {
        playButton.addEventListener('click', () => {
            log(`🔍 Play button clicked`);
            
            try {
                if (window.player) {
                    log(`🔍 Player exists, checking if ready`);
                    
                    if (window.player.isReady()) {
                        log('▶️ Player is ready, starting playback');
                        window.player.play();
                        window.playerState = 'playing';
                        
                        // Setup buffer logging
                        const intervalId = setInterval(() => {
                            if (window.playerState === 'playing') {
                                try {
                                    const videoBuffer = window.player.getBufferLength("video") || 0;
                                    const audioBuffer = window.player.getBufferLength("audio") || 0;
                                    log(`📊 Buffer levels: Video=${videoBuffer.toFixed(2)}s, Audio=${audioBuffer.toFixed(2)}s`);
                                } catch (e) {
                                    log(`⚠️ Error logging buffer levels: ${e.message}`);
                                }
                            } else {
                                clearInterval(intervalId);
                            }
                        }, 10000); // Log every 10 seconds
                        
                        if (!window.bufferLoggingIntervals) {
                            window.bufferLoggingIntervals = [];
                        }
                        window.bufferLoggingIntervals.push(intervalId);
                    } else {
                        log('⚠️ Player exists but not ready yet, waiting...');
                        window.playerState = 'buffering';
                        
                        // Try again in a second
                        setTimeout(() => {
                            try {
                                if (window.player && window.player.isReady()) {
                                    log('▶️ Player now ready, starting playback');
                                    window.player.play();
                                    window.playerState = 'playing';
                                } else {
                                    log('❌ Player still not ready after timeout');
                                }
                            } catch (e) {
                                log(`❌ Error starting playback after timeout: ${e.message}`);
                            }
                            updateUI();
                        }, 1000);
                    }
                    
                    updateUI();
                } else {
                    log('❌ Play button clicked but player not initialized');
                    alert('Player not initialized. Please wait for connection to establish and media to be received.');
                }
            } catch (error) {
                log(`❌ Error starting playback: ${error.message}`);
                alert(`Playback error: ${error.message}`);
            }
        });
    }

    // Disconnect button handler
    const disconnectButton = document.getElementById('disconnectButton');
    if (disconnectButton) {
        disconnectButton.addEventListener('click', () => {
            log(`🔍 Disconnect button clicked`);
            
            try {
                disconnectWebTransport();
                log(`✅ Disconnection completed successfully`);
            } catch (error) {
                log(`❌ Error during disconnection: ${error.message}`);
            }
        });
    }

    // Debug button handler
    const debugButton = document.getElementById('debugButton');
    if (debugButton) {
        debugButton.addEventListener('click', () => {
            log(`🔍 Debug button clicked`);
            debugMediaState();
            checkConnectionStatus();
            
            // Add any specific debugging you want here
            if (window.packetHandler) {
                const stats = window.packetHandler.getStats();
                log(`📊 Detailed Stats: ${JSON.stringify(stats)}`);
            }
        });
    }
    
    // Initialize UI
    updateUI();
    log(`✅ UI initialization completed`);
    
    log(`🔍 WebTransport DASH Player setup completed`);
});

/**
 * Update the UI based on current state
 */
function updateUI() {
    // Get UI elements
    const connStatus = document.getElementById('connectionStatus');
    const bufferStatus = document.getElementById('bufferStatus');
    const playerStatus = document.getElementById('playerStatus');
    const connectBtn = document.getElementById('connectButton');
    const playBtn = document.getElementById('playButton');
    const disconnectBtn = document.getElementById('disconnectButton');
    const packetCounter = document.getElementById('packetCounter');
    const streamCounter = document.getElementById('streamCounter');
    
    // Update connection status
    if (connStatus) {
        if (window.transport) {
            connStatus.textContent = 'Connected';
            connStatus.className = 'status-badge status-connected';
        } else {
            connStatus.textContent = 'Disconnected';
            connStatus.className = 'status-badge status-disconnected';
        }
    }
    
    // Update button states
    if (connectBtn) {
        connectBtn.disabled = !!window.transport;
    }
    
    if (disconnectBtn) {
        disconnectBtn.disabled = !window.transport;
    }
    
    // Update buffer status
    if (bufferStatus && window.packetHandler) {
        const stats = window.packetHandler.getStats();
        const audioCount = stats.audioFragments || 0;
        const videoCount = stats.videoFragments || 0;
        
        bufferStatus.textContent = `${audioCount + videoCount} (A:${audioCount}, V:${videoCount})`;
        
        if (audioCount + videoCount > 0) {
            bufferStatus.className = 'status-badge status-connected';
        } else {
            bufferStatus.className = 'status-badge';
        }
    } else if (bufferStatus) {
        bufferStatus.textContent = '0 (A:0, V:0)';
        bufferStatus.className = 'status-badge';
    }
    
    // Update player status
    if (playerStatus) {
        const state = window.playerState || 'idle';
        playerStatus.textContent = state.charAt(0).toUpperCase() + state.slice(1);
        
        if (state === 'buffering') {
            playerStatus.className = 'status-badge status-buffering';
        } else if (state === 'playing') {
            playerStatus.className = 'status-badge status-connected';
        } else if (state === 'error') {
            playerStatus.className = 'status-badge status-disconnected';
        } else {
            playerStatus.className = 'status-badge';
        }
    }
    
    // Update packet counter
    if (packetCounter && window.packetHandler) {
        const stats = window.packetHandler.getStats();
        packetCounter.textContent = stats.packetsReceived || 0;
        if (stats.packetsReceived > 0) {
            packetCounter.className = 'status-badge status-connected';
        } else {
            packetCounter.className = 'status-badge';
        }
    } else if (packetCounter) {
        packetCounter.textContent = '0';
        packetCounter.className = 'status-badge';
    }
    
    // Update stream counter
    if (streamCounter) {
        streamCounter.textContent = window.streamCounter || 0;
        if (window.streamCounter > 0) {
            streamCounter.className = 'status-badge status-connected';
        } else {
            streamCounter.className = 'status-badge';
        }
    }
    
    // Update play button
    if (playBtn) {
        // Enable play button only if player exists and has init segments and media
        let canPlay = false;
        
        if (window.player && window.packetHandler) {
            const stats = window.packetHandler.getStats();
            const hasMedia = stats.videoFragments > 0 && stats.audioFragments > 0;
            const isPlaying = window.playerState === 'playing' || window.playerState === 'buffering';
            
            canPlay = hasMedia && !isPlaying;
        }
        
        playBtn.disabled = !canPlay;
    }
}

/**
 * Simple logging function that outputs to both console and UI
 */
function log(message) {
    const logEl = document.getElementById('logcatbox');
    if (!logEl) {
        console.log(message);
        return;
    }
    
    const time = new Date().toISOString().split('T')[1].split('.')[0];
    const formattedMessage = `[${time}] ${message}`;
    
    logEl.value += formattedMessage + '\n';
    logEl.scrollTop = logEl.scrollHeight;
    console.log(message);
}

/**
 * Setup DASH.js player
 */
function setupDashPlayer(mpdUrl = '/vivoh.mpd') {
    if (window.player) {
        log(`📝 Player already exists, skipping creation`);
        return window.player;
    }

    try {
        log(`🎬 Creating DASH.js player (URL: ${mpdUrl})`);
        
        // Ensure video element exists
        let videoElement = document.getElementById('videoElement');
        if (!videoElement) {
            log(`🎥 Creating <video id="videoElement">`);
            videoElement = document.createElement('video');
            videoElement.id = 'videoElement';
            videoElement.className = 'centeredVideo';
            videoElement.controls = true;
            videoElement.autoplay = false;
            videoElement.muted = true; // Required for autoplay policies
            videoElement.playsinline = true;
            
            const container = document.querySelector('.video-container');
            if (container) {
                container.innerHTML = '';
                container.appendChild(videoElement);
            } else {
                document.body.appendChild(videoElement);
            }
        }
        
        // Create player with optimized settings
        window.player = dashjs.MediaPlayer().create();
        
        // Apply streaming settings
        window.player.updateSettings({
            'streaming': {
                'buffer': {
                    'fastSwitchEnabled': true,
                    'bufferTimeDefault': 20,           // Replaces stableBufferTime
                    'bufferTimeAtTopQuality': 30,
                    'bufferPruningInterval': 10
                },
                'gaps': {                              // Replaces jumpGaps and smallGapLimit
                    'jumpGaps': true,
                    'smallGapLimit': 1.5
                },
                'delay': {                             // Part of low latency settings
                    'liveDelay': 3,
                    'useSuggestedPresentationDelay': true
                },
                'liveCatchup': {                       // For low latency streams
                    'enabled': true,
                    'maxDrift': 0.5,
                    'playbackRate': {
                        'min': 0.5,
                        'max': 1.5
                    }
                }
            }
        });
        
        // Add event handlers
        window.player.on(dashjs.MediaPlayer.events.ERROR, (e) => {
            let errorDetail = '';
            if (e.error) {
                errorDetail = e.error.message || '';
                if (e.error.data) {
                    errorDetail += ` (${JSON.stringify(e.error.data)})`;
                }
            }
            log(`❌ Player error: ${errorDetail || 'Unknown error'}`);
            
            window.playerState = 'error';
            updateUI();
        });
        
        window.player.on(dashjs.MediaPlayer.events.PLAYBACK_STARTED, () => {
            log(`▶️ Playback started successfully`);
            window.playerState = 'playing';
            updateUI();
        });
        
        window.player.on(dashjs.MediaPlayer.events.PLAYBACK_PAUSED, () => {
            log(`⏸️ Playback paused`);
            window.playerState = 'paused';
            updateUI();
        });
        
        window.player.on(dashjs.MediaPlayer.events.PLAYBACK_WAITING, () => {
            log(`⏳ Playback waiting (buffering)`);
            window.playerState = 'buffering';
            updateUI();
        });
        
        window.player.on(dashjs.MediaPlayer.events.FRAGMENT_LOADING_COMPLETED, (e) => {
            if (e.request && e.request.mediaType) {
                log(`✅ Fragment loaded: type=${e.request.mediaType}, time=${e.request.startTime}`);
            }
        });
        
        // Initialize player
        window.player.initialize(videoElement, mpdUrl, false); // Autoplay=false
        log(`🎬 DASH.js player initialized with MPD URL: ${mpdUrl}`);
        
        window.playerState = 'ready';
        updateUI();
        
        return window.player;
    } catch (error) {
        log(`❌ Error creating DASH.js player: ${error.message}`);
        window.player = null;
        return null;
    }
}

    </script>
</body>
</html>